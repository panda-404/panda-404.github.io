<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Root的博客</title>
  
  <subtitle>教练我想打篮球</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-16T04:33:40.410Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Root</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识js</title>
    <link href="http://yoursite.com/2018/05/16/%E5%88%9D%E8%AF%86js/"/>
    <id>http://yoursite.com/2018/05/16/初识js/</id>
    <published>2018-05-16T04:29:21.000Z</published>
    <updated>2018-05-16T04:33:40.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识js"><a href="#初识js" class="headerlink" title="初识js"></a>初识js</h1><p>这是关于javascript的第一篇文章，还是得好好说说，之后的javascript相关部分就不再废话了，毕竟我是个追求简约的人(￣▽￣)／<br>记不得第一见识javascript是什么时候了，或许是看头条上文章中那些五颜六色的代码块的时候吧，不过那时候并不知道javascript是什么东东，毕竟我以为所有我用的东西都是纯java,c,c++实现的，而这三种语言是没有如此漂亮的代码的。。。后来javascript词频越来越高，也开始慢慢的对javascript有所了解。<br><a id="more"></a><br>javascript是一门创造出来解决一些简单前端验证的脚本语言，但是刚开始我也把它和java联系起来，认为javascript和java关系很紧密，当看到它语法时才知道这就像鱼香肉丝和鱼，老婆饼和老婆的关系一样。看到一段小历史才明白这样取名的原因。<br>javascript一开始叫做livescript，是伴随着浏览器netscape navigator出现的一门脚本语言，改名叫做javascript纯粹是新语言为了推广而和当时如日中天的java挂钩。这个名字也就一直延续到了现在，更是迷惑了许多像我这样“鱼香肉丝党”。</p><h1 id="js特点"><a href="#js特点" class="headerlink" title="js特点"></a>js特点</h1><ul><li>单线程：同一时间只能执行一件任务。</li><li>解释性语言：每读到一句js代码就翻译成二进制码执行，导致js运行速度比起编译性语言慢。</li><li>事件驱动：js目前主要用于网页中与用户的交互，用户操作鼠标键盘等设备触发页面绑定的事件执行对应的脚本。</li><li>弱类型：js中的变量没有java或是c中多样的变量类型，js中的声明的变量可以用于存储任意类型的值，甚至变量不声明也可以使用。</li><li>面向对象：js更关注使用对象能做什么，几乎所有操作都是基于对象的，在js中万物皆对象。</li><li>跨平台：依托于浏览器的js不用考虑java和c的平台支持，只要是支持js的浏览器，不用关心是什么平台都能运行。</li><li>js运行于浏览器处理了一些没必要靠后端处理的数据，减少了许多无意义的网络请求。</li><li><p>动态性：变量在运行时才知道具体是什么类型的值，并且定义的对象原型、方法等都可以重写改变。<br>js通过<code>script</code>标签就可引入到页面中</p><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1></li><li><p>原始值：存储在栈内存中的变量，值不可变。<br>js支持五种原始值类型：Number、String、Boolean、undefined、null。undefined和null只有自身一个值。其中null也算是对象类型，是用于给空对象占位的。</p></li><li><p>引用值：引用值的存储栈堆配合。栈内存引用堆内存的地址，堆内存中存储引用值的值。<br>三种引用值：Array、Object、Function<br>js中的运算符和流控制语句和其他语言别无二致，但是在浏览器环境中，js包括ECMAScript、DOM、BOM。ECMAScript是javascript交由ECMA协会制定的规范浏览器js实现，DOM(Document Object Model)文档对象模型，提供了供脚本操作页面文档对象的接口；BOM(Browser Object Model)提供脚本操作浏览器的接口。以下说的js一般指的是ECMAScript3。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>js中的数组有别于其他语言，弱数据类型的js允许数组中存储各种类型的数值，并且支持稀松数组，能够越界存取不会报错。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建一个len长的空数组，以undefined填充</span><br><span class="line">new Array(len)</span><br><span class="line">// 创建一个元素为x1,x2,x3...的数组</span><br><span class="line">new Array(x1,x2,x3...)</span><br><span class="line">// 多维数组</span><br><span class="line">var arr = [[],[],[]]</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>js中运算符和c及java没多大区别，都包含逻辑运算符，一元二元运算符等，只不过由于是脚本原因，一些运算符平时不太会用到，比如位运算符。位运算符会将数据转化为二进制数操作，因此速度上会提升不少，位运算符和逻辑运算符相似。</p><ul><li>按位非(~)<br>将原数转化成32位的二进制数后对这个二进制数每一位按位取非。</li><li>按位与(&amp;)<br>将两个操作数据转换成二进制数后，按两个二进制的每一位进行与操作，两位都是1返回1否则为0。</li><li>按位或(|)<br>类似按位与，当两个比较位全为0返回0，否则返回1。</li><li>按位异或(^)<br>两个比较位相同时为0，否则为1.</li><li><p>左移(&lt;&lt;)、有符号右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;)<br>将二进制数进行移位操作，左移不用考虑会以0填充空白位置，有符号右移以符号位填充空白，无符号右移以0填充空白位置。</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>js中在操作数据时存在显示类型转换和隐式类型转换。</p></li><li>显示类型转换：通过调用调用一些原生对象将数据转换成所需要的类型，如Number(),String(),Boolean(),toString(),ParseInt(),ParseFloat()</li><li><p>隐式类型转换：isNaN(),一些一元操作符、布尔操作符、关系操作符、相等操作符等操作符时，会发生隐式的类型转换,保证操作符操作的两个数属于同种类型，在大部分数学操作符情况下是数字优先，加性操作符字符串优先，关系和布尔则是布尔值优先。<br>当然有的时候在比较两个值时我们并不希望发生类型转换，这时需要用<code>===</code>操作符。undefined和null在比较中不会发生类型转换，虽然这两者的布尔类型值为0，但是两者与0的关系运算都为<code>false</code>，且规定undefined == null为true，<em>NaN == NaN为false</em></p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>js中一切可操作的东西都是对象，对象有属性的增删改查功能，对象创建推荐使用对象字面量方法，此外还可以通过构造函数创建</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>js中的函数实际也是对象，函数命名推荐小驼峰式写法，创建方法有构造函数、函数声明、函数表达式。有两种函数表达式：命名函数表达式、匿名函数表达式。</p></li><li>命名函数表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = function test() &#123;&#125; //后面的test名字可以与前面不同，函数调用时只识别前一个test，后一个test作为字符串在test.name中保存。</span><br></pre></td></tr></table></figure><ul><li>匿名函数表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test = function () &#123;&#125; //和命名函数表达式区别是test.name=test</span><br></pre></td></tr></table></figure><p>函数的参数保存在<code>arguments</code>这个类数组中，且形参实参个数可以不对应，当形参实参有映射关系，一个改变，另一个也变。arguments实际是一个对象，含有以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arguments.callee //指向当前函数本身，常用于匿名函数调用自身</span><br><span class="line">arguments.caller //返回当前函数的调用者，即this</span><br><span class="line">arguments.length //返回当前参数长度</span><br></pre></td></tr></table></figure><ul><li>立即执行函数<br>将函数变成表达式可以被<code>()</code>立即执行。一元运算符和逻辑操作符赋值给变量等可以使函数变成表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;</span><br><span class="line"> console.log(a);</span><br><span class="line">&#125;(1))</span><br><span class="line"></span><br><span class="line">var aa = function (a) &#123;</span><br><span class="line"> console.log(a);</span><br><span class="line">&#125;(1)</span><br><span class="line">//访问aa未定义</span><br></pre></td></tr></table></figure><h1 id="构造函数即自定义构造函数"><a href="#构造函数即自定义构造函数" class="headerlink" title="构造函数即自定义构造函数"></a>构造函数即自定义构造函数</h1><ul><li>Object(),String(),Array(),Date(),RegExp()等等是js中的内置对象，通过new操作符可以产生对应类型的对象。</li><li>自定义构造函数和普通函数没什么区别，只是为了和普通函数区分而认为规定了构造函数采用大驼峰式写法，首字母大写。<br>构造函数简易原理：</li></ul><ol><li>在函数体开始的地方创建this对象。</li><li>将对应的方法属性保存到this对象上。</li><li><p>隐式返回this<br>当构造函数没有用new操作符时，相当于函数执行，此时this指向运行时的环境。</p><blockquote><p>constructor返回对象的构造函数</p></blockquote></li></ol><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>包装类是为了避免在对Number,String,Boolean原始值按对象操作时不报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var num = 123;</span><br><span class="line">//隐式new Number(123).say = &apos;123&apos;;</span><br><span class="line">num.say = &apos;123&apos;;</span><br><span class="line">//进行属性赋值操作后delete Number(123).abc</span><br><span class="line">//访问num.say = undefined;</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域规定了变量能够被访问调用的环境，在函数外声明的变量是全局变量作用域就是全局。在函数中声明的变量作用域是函数及函数嵌套的代码。js中只有函数作用域，没有块级作用域，在for循环中声明的变量全局window也能访问(假设是在全局的for语句)。<br>作用域链是函数保存在[[scope]]属性中的作用域中能够访问的对象的集合，每个函数在被创建时都会将全局对象(GO)放在作用域链的最底端，在函数运行时又会创建一个运行期上下文和一个活跃对象(AO)放在作用域链顶端，定义了函数运行时的环境this,形参等等。函数每一次调用都会产生一个全新的运行期上下文，在函数执行完毕之后函数自己的运行期上下文就被销毁并销毁对AO的引用，查找访问变量时，遵循从上往下原则，优先从活跃对象AO中查找，再顺着作用域链往下查找，若没找到则为未定义。</p><blockquote><p>bind，call，apply可以改变运行时的上下文；with,try-catch会改变作用域链。</p></blockquote><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>当被当作返回值保存到外部的内部函数访问包含它的外部函数的作用域链时会产生闭包，闭包会导致本来应该随着外部函数执行完毕而销毁的AO不被释放而需要更多的内存，因为内部函数包含了外部函数的作用域。这里引用高性能javascript上的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function assignEvents()&#123;</span><br><span class="line"> var id = &quot;xdi9592&quot;;</span><br><span class="line"> document.getElementById(&quot;save-btn&quot;).onclick = function(event)&#123;</span><br><span class="line"> saveDocument(id);</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="clipboard.png" alt="闭包"><br>本应该随着assignEvents执行完毕销毁的assignEvents的AO，因为事件监听中saveDocument还有对AO的引用，导致AO占用的内存没有被释放，产生了内存泄露的问题。<br>合理使用闭包可以创造出很多实用的功能，例如累加器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function accumulator() &#123;</span><br><span class="line"> var count = 0;</span><br><span class="line"> function add() &#123;</span><br><span class="line"> count ++;</span><br><span class="line"> console.log(count);</span><br><span class="line"> &#125;</span><br><span class="line"> return add;</span><br><span class="line">&#125;</span><br><span class="line">var demo = accumulator();</span><br><span class="line">demo();</span><br></pre></td></tr></table></figure><h1 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h1><p>原型链是作用域链的延伸。原型是一个对象，包含了一些自身属性。在谷歌中如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Test() &#123;</span><br><span class="line"> this.name = &apos;test&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var test = new Test();</span><br></pre></td></tr></table></figure><p><img src="prototype.png" alt="prototype"><br>其中<strong>proto</strong>是在火狐和chrome中实现的对象(这里是test)的原型属性，标准属性是[[Prototype]]，prototype是函数(这里是test的构造函数Test)的原型。就这样，实例对象的原型<strong>proto</strong>指向了构造函数的原型Test.prototype，构造函数原型对象Test.prototype的原型Test.prototype.<strong>proto</strong>指向Object.prototype(并且构造函数还具有constructor属性指向构造器Test函数)。这种指向关系构成了原型链。<br>有了原型链就可以通过在构造函数的原型上添加属性，构造函数的实例对象可以继承构造函数原型上的方法属性。这是js中实现继承的主要方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Test() &#123;</span><br><span class="line"> this.name = &apos;test&apos;;</span><br><span class="line">&#125;</span><br><span class="line">Test.prototype.sayName = function() &#123;</span><br><span class="line"> console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var test = new Test();</span><br><span class="line">test.sayName(); //打印出&apos;test&apos;</span><br></pre></td></tr></table></figure><blockquote><p>使用new创建的对象原型为Object.prototype，构造函数实例化对象的原型为构造函数的prototype,Object.create能够创建指定原型的对象。</p></blockquote><h1 id="js运行机制"><a href="#js运行机制" class="headerlink" title="js运行机制"></a>js运行机制</h1><ul><li>语法分析：先将所有代码检查一遍看有无语法错误。</li><li>全局预编译：</li></ul><ol><li>生成GO对象</li><li>变量声明作为GO属性，值为undefined。</li><li>函数声明的函数名作为GO属性，值为函数体。</li></ol><ul><li>函数预编译：</li></ul><ol><li>创建执行期上下文和AO对象。</li><li>将形参和变量名作为AO的属性名，值为undefined</li><li>传入的实参赋值给形参。</li><li><p>将函数声明的函数名作为AO属性，值为函数体。</p><blockquote><p>未经声明的任何变量都看做是window对象的属性，同时声明的全局变量也是window的属性，区别是未经声明的变量可以delete删除，因为configurable=true，而声明的变量不能通过删除属性的delete删除</p></blockquote></li></ol><p>本篇完，算是对js的总体认识，之后再对原型继承和数组正则等进行扩充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初识js&quot;&gt;&lt;a href=&quot;#初识js&quot; class=&quot;headerlink&quot; title=&quot;初识js&quot;&gt;&lt;/a&gt;初识js&lt;/h1&gt;&lt;p&gt;这是关于javascript的第一篇文章，还是得好好说说，之后的javascript相关部分就不再废话了，毕竟我是个追求简约的人(￣▽￣)／&lt;br&gt;记不得第一见识javascript是什么时候了，或许是看头条上文章中那些五颜六色的代码块的时候吧，不过那时候并不知道javascript是什么东东，毕竟我以为所有我用的东西都是纯java,c,c++实现的，而这三种语言是没有如此漂亮的代码的。。。后来javascript词频越来越高，也开始慢慢的对javascript有所了解。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js类型判断</title>
    <link href="http://yoursite.com/2018/05/16/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2018/05/16/js类型判断/</id>
    <published>2018-05-16T04:24:56.000Z</published>
    <updated>2018-05-16T04:28:11.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js类型判断"><a href="#js类型判断" class="headerlink" title="js类型判断"></a>js类型判断</h1><p>今天才想起来漏写了类型检测，现在补上。。。<br><a id="more"></a></p><h1 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h1><p>在js中有6中数据类型：Number,String,Boolean,Null,Undefined,Object。有时候我们需要对值做类型检测，判断是原始值类型还是对象，是何种对象。这篇就总结下类型判断的常见方法。</p><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>这是类型判断最基础的方法，能判断出number,string,boolean,undefined,object,function</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, &apos;1&apos;, false, null, undefined, &#123;num:1&#125;, [1], function()&#123;&#125;];</span><br><span class="line">console.log(arr)</span><br><span class="line">for(var i = 0, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class="line"> console.log(typeof(arr[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="typeof.png" alt="类型检测"><br>可以看到用typeof检测时，将null也视为object，这是因为在以往null是用来给空对象占位的，但是在现在null意为这里不该有值。此外，虽然typeof能将function能将函数类型从object区分出来，但是比如日期对象、数组对象，typeof并不能区分。</p><h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><p>通过Object.prototype.toString可以返回一个<code>[Object 类型]</code>字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, &apos;1&apos;, false, null, undefined, &#123;num:1&#125;, [1], function()&#123;&#125;];</span><br><span class="line">console.log(arr)</span><br><span class="line">for(var i = 0, len = arr.length; i &lt; len; i ++) &#123;</span><br><span class="line"> console.log(Object.prototype.toString.call(arr[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="toString.png" alt="类型检测"><br>可以自行试验一下，Object.prototype.toString可以判断几乎所有的数值与对象类型。<br>这里补充一下，直接调用toString方法会返回一个包含this指向的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(toString(obj));</span><br><span class="line">console.log(window.toString(obj));</span><br><span class="line">console.log(toString.call(null, obj));</span><br><span class="line">console.log(toString(null));</span><br><span class="line">console.log(toString(undefined));</span><br></pre></td></tr></table></figure><p><img src="toString1.png" alt="直接调用toString"></p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>instanceof判断待检测值原型链上是否有对应构造函数的原型。这并不是一个完善的方法，因为对于原始值类型，并不存在原型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;,</span><br><span class="line"> arr = [];</span><br><span class="line">function fn() &#123;&#125;</span><br><span class="line">obj instanceof Object //true</span><br><span class="line">arr instanceof Array //true</span><br><span class="line">arr instanceof Object //true</span><br><span class="line">fn instanceof Function //true</span><br><span class="line">arr instanceof Function //false</span><br><span class="line">fn instanceof Object //true</span><br></pre></td></tr></table></figure><blockquote><p>在谷歌控制台中，貌似为声明的对象进行instanceof和算术运算会被转换成空，如下<br><img src="consoleObj.png" alt="控制台空对象"><br>原因虽然还不清楚，但是一般也不会直接在控制台进行操作。<br>本篇完。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;js类型判断&quot;&gt;&lt;a href=&quot;#js类型判断&quot; class=&quot;headerlink&quot; title=&quot;js类型判断&quot;&gt;&lt;/a&gt;js类型判断&lt;/h1&gt;&lt;p&gt;今天才想起来漏写了类型检测，现在补上。。。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初识DOM</title>
    <link href="http://yoursite.com/2018/05/16/%E5%88%9D%E8%AF%86DOM/"/>
    <id>http://yoursite.com/2018/05/16/初识DOM/</id>
    <published>2018-05-16T04:18:55.000Z</published>
    <updated>2018-05-16T04:23:40.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识DOM"><a href="#初识DOM" class="headerlink" title="初识DOM"></a>初识DOM</h1><p>前几篇简略的将js的知识复习了一遍，不过还有很多方法、函数式、ES5,6的新特性没概括，之后再补充吧。现在开始了解前端的另一个核心–DOM<br><a id="more"></a><br>DOM是<code>Document Object Model</code>的简写，主要功能是用以操作文档，文档能够被操作，是因为在解析页面时将文档结构创建为<code>document</code>对象，html文档中的一个个标签以<code>html</code>节点为根节点构建为有父子结构的树状结构，将文档中的标签转变为可以操作的节点。<br><img src="DOMtree.jpg" alt="节点树"></p><h1 id="针对节点的操作"><a href="#针对节点的操作" class="headerlink" title="针对节点的操作"></a>针对节点的操作</h1><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><p>节点查找常见有以下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//选出实时变化的元素类数组</span><br><span class="line">document.getElementsByTagName()</span><br><span class="line">document.getElementsByClassName()</span><br><span class="line">document.getElementById()</span><br><span class="line"></span><br><span class="line">//选出非实时变化的元素类数组</span><br><span class="line">document.querySelector()</span><br><span class="line">document.querySelectorAll()</span><br></pre></td></tr></table></figure></p><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.createElement()</span><br><span class="line">document.createTextNode()</span><br><span class="line">document.createComment()</span><br></pre></td></tr></table></figure><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注意这两种方法都有剪切作用</span><br><span class="line">parent.appendChild(child)</span><br><span class="line">//在next前插入pre</span><br><span class="line">parent.insertBefore(pre,next)</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//removeChild也有剪切作用，返回被删除节点</span><br><span class="line">parent.removeChild(child)</span><br><span class="line">child.remove()</span><br></pre></td></tr></table></figure><h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//new替换origin同时返回origin</span><br><span class="line">parent.replaceChild(new, origin)</span><br></pre></td></tr></table></figure><p>document对象上还定义了一些其他属性方法如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.write() //重写整个文档</span><br><span class="line">document.open() //擦除当前文档并新开一个文档</span><br><span class="line">document.close() //关闭当前文档</span><br><span class="line">document.anchors //文档中锚点的集合</span><br><span class="line">document.domain //设置或返回当前文档域名</span><br><span class="line">document.title //当前文档标题</span><br></pre></td></tr></table></figure><h1 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h1><p>每个节点都可以当作一个对象，提供了大量属性和方法，不仅仅能够操作节点本身，就不一一介绍了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node.innerHTML</span><br><span class="line">node.attributes</span><br><span class="line">node.getAttribute()</span><br><span class="line">node.setAttribute()</span><br><span class="line">node.lastChild</span><br><span class="line">node.nextSibling</span><br><span class="line">node.offsetHeight</span><br><span class="line">node.parentNode</span><br><span class="line">node.style</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初识DOM&quot;&gt;&lt;a href=&quot;#初识DOM&quot; class=&quot;headerlink&quot; title=&quot;初识DOM&quot;&gt;&lt;/a&gt;初识DOM&lt;/h1&gt;&lt;p&gt;前几篇简略的将js的知识复习了一遍，不过还有很多方法、函数式、ES5,6的新特性没概括，之后再补充吧。现在开始了解前端的另一个核心–DOM&lt;br&gt;
    
    </summary>
    
    
      <category term="DOM" scheme="http://yoursite.com/tags/DOM/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>盒模型与布局--盒模型篇</title>
    <link href="http://yoursite.com/2018/05/16/%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%B8%83%E5%B1%80-%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/16/盒模型与布局-盒模型篇/</id>
    <published>2018-05-16T03:58:43.000Z</published>
    <updated>2018-05-16T04:16:25.881Z</updated>
    
    <content type="html"><![CDATA[<p>我发现一点一滴的记录似乎对我没有多大意义，莫不如直接看文档，所以索性挑些我遇到的一些重点谈谈。</p><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>html中引入了一个形象的模型–盒模型，来描述html中的元素，不过在说盒模型前，得再次谈谈html中的三种元素类型：block,inline,inline-block。可通过<code>display</code>属性切换，该属性了解以下值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display: inline|block|inline-block|table|table-cell|grid|none|inherit;</span><br></pre></td></tr></table></figure><h2 id="1-block"><a href="#1-block" class="headerlink" title="1. block"></a>1. block</h2><p>这是最灵活也是最常用的一种元素类型，典型代表<code>&lt;div&gt;</code>。特征：<br><a id="more"></a></p><ul><li>可以设置宽高内外边距，宽度默认是父元素100%</li><li>元素独占一行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div&#123;</span><br><span class="line"> height: 30px;</span><br><span class="line"> background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div&gt;我是块&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="block.png" alt="block"></p><blockquote><p>注意四周留出的空白，这是body的默认样式margin: 8px;</p></blockquote><h2 id="2-inline"><a href="#2-inline" class="headerlink" title="2.inline"></a>2.inline</h2><p>代表：<code>&lt;span&gt;</code>，特征：</p><ul><li>不可以设置宽高,内外边距能否设置视情况而定</li><li>内容决定了占据大小</li><li>和其他元素在同一行排列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">span&#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;span&gt;我是行级&lt;/span&gt;</span><br><span class="line">&lt;span&gt;我是行级&lt;/span&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="inline.png" alt="inline"><br>可以看到设置的宽高并没有生效，并且两个元素之间出现了间隙。之所以产生间隙，这也是行级元素的特性之一，拥有文本特性，即元素之间的空格、换行、tab会导致元素之间产生间隙，这个间隙是由父元素的<code>font-size</code>属性决定的。解决办法也有多种：</p><ul><li><p>最简单直接就是使元素之间没有空格，但是这些方法对于多个标签操作太麻烦了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使元素不换行</span><br><span class="line">- &lt;span&gt;我是行级&lt;/span&gt;&lt;span&gt;我是行级&lt;/span&gt;</span><br><span class="line">注释空格</span><br><span class="line">- &lt;span&gt;我是行级&lt;/span&gt;&lt;!--</span><br><span class="line">--&gt;&lt;span&gt;我是行级&lt;/span&gt;</span><br><span class="line">使用margin: -4px;</span><br><span class="line">- span&#123;</span><br><span class="line">  &lt;!-- ... --&gt;</span><br><span class="line">  margin: -4px; //取决于字体大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使父元素font-size: 0;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.spanparent &#123;</span><br><span class="line"> font-size: 0;</span><br><span class="line">&#125;</span><br><span class="line">.spanparent span &#123;</span><br><span class="line"> font-size: 14px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运用css属性letter-spacing或者word-spacing，不过还是得根据字体大小设定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.spanparent &#123;</span><br><span class="line"> letter-spacing: -4px;</span><br><span class="line"> /*word-spacing: -4px;*/</span><br><span class="line">&#125;</span><br><span class="line">.spanparent span &#123;</span><br><span class="line"> letter-spacing: 0;</span><br><span class="line"> /*word-spacing: 0;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="再说边距的问题"><a href="#再说边距的问题" class="headerlink" title="再说边距的问题"></a>再说边距的问题</h3><p>html元素还可分为替换元素和非替换元素，行内元素能否设置边距就与这两者相关</p><ul><li>非替换元素：内容包含在标签中，如<code>&lt;span&gt;</code> <code>&lt;p&gt;</code></li><li>替换元素：内容由外部引入，不在标签之中，如<code>&lt;img&gt;</code> <code>&lt;input&gt;</code><br>那么问题来了，前面为什么说行级元素能否设置内外边距视情况而定呢？这就是原因。<br>对于非替换元素，可以理解为只有水平方向上的边距是有作用的。<br>而对于替换元素，则可以像块级元素一样设置内外边距宽高。<br>看个例子，页面结构如下：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"span1"</span>&gt;</span>我是行级.span1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"span2"</span>&gt;</span>我是行级.span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"这是个输入框"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>样式表<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.span1</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30px</span>;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">30px</span>;</span><br><span class="line"> <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">background</span>: yellow;</span><br><span class="line"> <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.span2</span> &#123;</span><br><span class="line"> <span class="attribute">padding-top</span>: <span class="number">30px</span>;</span><br><span class="line"> <span class="attribute">background</span>: blue;</span><br><span class="line"> <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"> <span class="attribute">background</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如图：<br><img src="inlinedemo.png" alt="demo"><br>可以看到.span1确实有左右margin和padding，且忽略的设置的宽高，可替换元素input能够像块级元素一样操作，但是等等，再看中间的.span2，这就是所谓的非替换元素设置垂直方向的边距失效，虽然视觉上有效果，但是.span2的上内边距并没有起到占位的作用，不会对其他元素造成影响（但是为什么要这么做还不太清楚）。总而言之，给非替换元素设置垂直方向边距是无效的。</p><h2 id="3-inline-block"><a href="#3-inline-block" class="headerlink" title="3.inline-block"></a>3.inline-block</h2><p>这不是默认display属性的一种，但是可配置，使元素同时具有行级和块级的特性（说起来挺像行级替换元素）</p><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h2><p>其他类型的display属性值就不再详细介绍：<code>display: none</code>隐藏元素，<code>display: inherit</code>属性由父元素继承来，<code>display: table</code>搭配<code>display: table-cell</code>等可以做到类似css3中flex弹性盒子的效果。</p><ul><li>display: grid<br>这是一种类似table布局的新css属性，主要搭配如下几个属性实现网格布局：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义每行的高度，行间距</span><br><span class="line">grid-template-rows: rowheight1 rowmargin1 rowheight2 rowmargin2 rowheight3;</span><br><span class="line">定义每列宽度间距</span><br><span class="line">grid-template-columns: colwidth1 colmargin1 colwidth2 colmargin2 colwidth3;</span><br><span class="line">定义单元格位置</span><br><span class="line">grid-column: start/end;</span><br><span class="line">grid-row: start/end;</span><br><span class="line">或者以这种复合形式</span><br><span class="line">grid-area: rowstart/colstart/rowend/colend;</span><br></pre></td></tr></table></figure><h1 id="盒模型从这儿开始"><a href="#盒模型从这儿开始" class="headerlink" title="盒模型从这儿开始"></a>盒模型从这儿开始</h1><p>上面介绍的是元素的类型，从这里开始正式的介绍我们的主角–盒模型（元素框）。盒模型是文档中用于布局的主要模型，可以理解为HTML元素的化身，描述了元素在文档中的大小及位置，我们以<code>&lt;div&gt;</code>为例。<br><img src="boxmodel.png" alt="boxmodel"><br>如图就是一个盒模型的结构，包含content,padding,border,margin四部分，对于有定位的元素还有position用于描述元素的位置。<br>盒模型又分为w3c标准盒模型以及IE盒模型，区别是对盒子宽高的定义</p><ul><li><p>w3c标准盒模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width = contentWidth</span><br><span class="line">height = contentHeight</span><br></pre></td></tr></table></figure></li><li><p>IE盒模型</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height/width = content + padding + border</span><br></pre></td></tr></table></figure><p>从以上公式可以看出区别，w3c标准盒模型中，设定的宽度为内容区宽度，而IE盒模型中，设置的宽度被内容区、内边距、边框共同占用。</p><blockquote><p>文档声明头doctype规定了浏览器以w3c标准解释盒模型，若没有声明，则看浏览器厂商的心情了。可以设置box-sizing: border-box;按照IE盒模型解释，默认content-box，个人觉得IE盒模型似乎更好用些。。。</p></blockquote><h2 id="block-level-box-amp-inline-level-box"><a href="#block-level-box-amp-inline-level-box" class="headerlink" title="block-level-box&amp;inline-level-box"></a>block-level-box&amp;inline-level-box</h2><p>以上是盒模型的简介，众所周知，元素分为块级元素和行级元素，那么这两种元素是如何依据盒模型体现在布局渲染中的呢？这就引入了块级盒&amp;行级盒。一般块级元素会生成块级盒，行级元素生成行级盒。特性已经在上面<code>display: block|inline</code>描述过了。</p><blockquote><p>元素会根据display属性来决定以何种上下文规则渲染(BFC、IFC属于FC(Formatting Context)，是一套盒子的渲染方式，下一篇讲)，我对盒模型和格式化上下文的理解比较混乱，还得多学习啊！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我发现一点一滴的记录似乎对我没有多大意义，莫不如直接看文档，所以索性挑些我遇到的一些重点谈谈。&lt;/p&gt;
&lt;h1 id=&quot;盒模型&quot;&gt;&lt;a href=&quot;#盒模型&quot; class=&quot;headerlink&quot; title=&quot;盒模型&quot;&gt;&lt;/a&gt;盒模型&lt;/h1&gt;&lt;p&gt;html中引入了一个形象的模型–盒模型，来描述html中的元素，不过在说盒模型前，得再次谈谈html中的三种元素类型：block,inline,inline-block。可通过&lt;code&gt;display&lt;/code&gt;属性切换，该属性了解以下值：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;display: inline|block|inline-block|table|table-cell|grid|none|inherit;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-block&quot;&gt;&lt;a href=&quot;#1-block&quot; class=&quot;headerlink&quot; title=&quot;1. block&quot;&gt;&lt;/a&gt;1. block&lt;/h2&gt;&lt;p&gt;这是最灵活也是最常用的一种元素类型，典型代表&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;。特征：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端滚动加载</title>
    <link href="http://yoursite.com/2018/05/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/05/14/移动端滚动加载/</id>
    <published>2018-05-14T08:53:34.000Z</published>
    <updated>2018-05-16T03:39:24.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>最近没什么事情，得以有空实现一个小功能。移动端滚动加载是比较常见的需求，类似这样，样式将就看看，不是重点<br><img src="滚动加载.gif" alt="滚动效果"><br>首先分析一下实现这个效果需要做些什么：</p><ol><li>布局上：导航吸底再就是滚动区域</li><li>滚动功能：根据滚动距离执行加载逻辑<br>下面就这两个方向实现我们的功能。<a id="more"></a><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3>对于布局，我一开始是想的这两种写法<blockquote><p>盒模型是border-box基础上</p></blockquote></li><li>方法一<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scroll-content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tabs"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scroll-content</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">90vh</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10vh</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tabs</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scroll-content</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个<code>-webkit-overflow-scrolling: touch</code>是为了解决在ios中滚动卡顿没有弹性滚动的问题，还有吸底为什么不用<code>fixed</code>呢？因为在移动端它的表现不是很好，可能会出现滚动时元素抖动的情况。<br>观察滚动条滚动行为可以知道，采用方案二会导致滚动条滚动到被tabs覆盖的区域，故不采用，那么方案一呢？乍看是没有问题，但是测试的时候发现，在ios下尤其ipad，出现些让人脑壳疼的后果，有<code>-webkit-overflow-scrolling</code>后，滚动区域会遮住底部导航,除非将滚动元素放在导航区域的前面(尚没追究具体原因，大概和层级有关)，因此也没有采用这种方式。最后按如下布局：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scroll-wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scroll-content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tabs"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scroll-wrapper</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10vh</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scroll-content</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(255, 255, 255, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scroll-content</code>利用<code>height: 100%</code>占满父容器剩余高度，其中<code>-webkit-tap-highlight-color</code>属性是为了避免在ios下点击元素出现灰色背景。<br>布局大概就是这样，具体细节再调整。</p><h3 id="滚动功能"><a href="#滚动功能" class="headerlink" title="滚动功能"></a>滚动功能</h3><p>滚动可能第一时间想到的是<code>scroll</code>事件，确实，但是网上有的帖子说在ios中，<code>scroll</code>的触发会出现只有滚动停止后才触发<code>scroll</code>事件的问题，貌似是因为之前的ios版本中，苹果对第三方的浏览器内核做了限制，最终导致这个问题，不过我并没有复现，但是还是主要使用<code>touchmove</code>事件来做滚动吧。<br>再进一步分析，<code>touchmove</code>和<code>scroll</code>事件都是高频触发的，但是我们的需求并不需要太高的触发频率，这里采用节流函数，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prevTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span>(newTime - prevTime &gt; delay) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            prevTime = newTime</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没使用防抖是因为节流更符合我们的场景，除非每次手指滚动的过程比较短促，否则防抖会影响加载事件的触发。不过接下来这个场景会用到防抖（当然也可以使用节流，不过节流有时候会出现问题，之后会说，这里还是使用防抖介绍一下吧）。<br>先看一个效果，也就是之前针对ios添加的<code>-webkit-overflow-scrolling</code><br><img src="弹性滚动.gif" alt="弹性滚动"><br>在滚动手势结束后，页面还会依惯性滚动一段距离，我希望在惯性滚动过程也检测是否需要执行加载逻辑，有以下几种方案：</p><ol><li>使用节流，按一定频率定时触发检测</li><li>使用防抖，在滚动开始及结束后检测</li><li>防抖节流搭配使用，固定频率检测+滚动结束后检测<br>分析：<br>方案一，一般情况下表现正常，但是如果惯性滚动加速度过大，第一次检测后马上就滚动到底部，delay时间内就完成了整个滚动行为，加载函数不能正常执行<br>方案二，缺点也比较明显，滚动完成后需要等待delay时间才执行检测函数<br>那么就采用方案三，以下是更改后的节流函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prevTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> timeOutFn</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newTime = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        timeOutFn = timeOutFn ? timeOutFn : <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(newTime - prevTime &gt;= delay) &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">            prevTime = newTime</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer = setTimeout(timeOutFn, <span class="number">150</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个功能是基于vue指令完成的，因为需要获取元素的滚动位置，所以选择在inserted钩子中编写代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"fofo"</span> <span class="attr">class</span>=<span class="string">"load-wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test-content"</span> <span class="attr">v-load-more</span>=<span class="string">"loading"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test-item"</span> <span class="attr">v-for</span>=<span class="string">"item in testData"</span> <span class="attr">:key</span>=<span class="string">"item.key"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left-area"</span> <span class="attr">:style</span>=<span class="string">"item.styleObj"</span>&gt;</span>&#123;&#123;item.item&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right-area"</span>&gt;</span>&#123;&#123;item.content&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"no-more-content"</span> <span class="attr">v-if</span>=<span class="string">"loaded"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"no-more-dec"</span>&gt;</span>没有更多内容了<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>模拟加载函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">loading() &#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.isLoading || <span class="keyword">this</span>.loaded) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'is loading'</span>)</span><br><span class="line">  <span class="keyword">this</span>.isLoading = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span>.startNum ++</span><br><span class="line">  <span class="keyword">let</span> timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempArr = _this.genData()</span><br><span class="line">    _this.testData = _this.testData.concat(tempArr)</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">    _this.isLoading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span>(_this.startNum == <span class="number">5</span>) &#123;</span><br><span class="line">      _this.loaded = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'loaded'</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指令通过mixins混合<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; debounce, throttle &#125; <span class="keyword">from</span> <span class="string">'./tools'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loadMore = &#123;</span><br><span class="line">    directives: &#123;</span><br><span class="line">        <span class="string">'load-more'</span>: &#123;</span><br><span class="line">            inserted(el, binding) &#123;</span><br><span class="line">                <span class="keyword">let</span> elHeight = el.clientHeight</span><br><span class="line">                <span class="keyword">let</span> elInnerHTML = el.innerHTML</span><br><span class="line">                <span class="keyword">let</span> fn = binding.value</span><br><span class="line">                <span class="keyword">let</span> elScrollHeight</span><br><span class="line">                <span class="keyword">let</span> elScrollTop</span><br><span class="line">                <span class="keyword">let</span> checkScroll</span><br><span class="line">                <span class="keyword">let</span> callback</span><br><span class="line"></span><br><span class="line">                checkScroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    elScrollTop = el.scrollTop</span><br><span class="line">                    elScrollHeight = el.scrollHeight</span><br><span class="line">                    <span class="keyword">return</span> elScrollHeight - elHeight - elScrollTop &lt;= <span class="number">100</span></span><br><span class="line">                &#125;</span><br><span class="line">                callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (checkScroll()) &#123;</span><br><span class="line">                        fn()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                el.addEventListener(<span class="string">'touchmove'</span>, throttle(callback, <span class="number">300</span>), <span class="literal">false</span>)</span><br><span class="line">                el.addEventListener(<span class="string">'scroll'</span>, throttle(callback, <span class="number">200</span>), <span class="literal">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="最终效果.gif" alt="最终效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h2&gt;&lt;p&gt;最近没什么事情，得以有空实现一个小功能。移动端滚动加载是比较常见的需求，类似这样，样式将就看看，不是重点&lt;br&gt;&lt;img src=&quot;滚动加载.gif&quot; alt=&quot;滚动效果&quot;&gt;&lt;br&gt;首先分析一下实现这个效果需要做些什么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;布局上：导航吸底再就是滚动区域&lt;/li&gt;
&lt;li&gt;滚动功能：根据滚动距离执行加载逻辑&lt;br&gt;下面就这两个方向实现我们的功能。
    
    </summary>
    
    
      <category term="功能" scheme="http://yoursite.com/tags/%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>说明</title>
    <link href="http://yoursite.com/2018/05/10/%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/05/10/说明/</id>
    <published>2018-05-10T02:26:50.000Z</published>
    <updated>2018-05-16T04:38:55.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是一篇说明"><a href="#这是一篇说明" class="headerlink" title="这是一篇说明"></a>这是一篇说明</h2><p>非常悲伤，以前写的博客没有及时备份，过年电脑出问题后就只剩下最初的三篇了。但是问题不大，以后多注意下备份，千万别再出问题了。<br>好在之前把博客离线了下来，但是离线也出了问题，最终还是只拯救回来四篇。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这是一篇说明&quot;&gt;&lt;a href=&quot;#这是一篇说明&quot; class=&quot;headerlink&quot; title=&quot;这是一篇说明&quot;&gt;&lt;/a&gt;这是一篇说明&lt;/h2&gt;&lt;p&gt;非常悲伤，以前写的博客没有及时备份，过年电脑出问题后就只剩下最初的三篇了。但是问题不大，以后多注意下备份，千
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://yoursite.com/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>CSS简介</title>
    <link href="http://yoursite.com/2017/10/30/CSS%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/10/30/CSS简介/</id>
    <published>2017-10-30T12:30:35.000Z</published>
    <updated>2018-04-27T02:36:42.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>CSS全称Cascading Style Sheet层叠样式表，它的提出是为了解决一开始HTML各种显示功能的发展导致了HTML页面混乱臃肿。CSS的作用是定义HTML等文件的样式，使样式和页面结构分离开，便于之后再次更改样式。就如同html文件是一个涂色本，你可以任意规定某个部分的颜色，页面的表现不在和页面结构相关。CSS的内容主要分为选择器和样式属性。<br><a id="more"></a></p><h2 id="2-CSS引入"><a href="#2-CSS引入" class="headerlink" title="2.CSS引入"></a>2.CSS引入</h2><p>一般CSS有三种引入页面的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 页面级css</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">&lt;!--style的type属性规定了文件的数据类型(MIME)，</span><br><span class="line">这儿type只有唯一值text/css，现在可以忽略type属性，</span><br><span class="line">style标签的默认type类型为text/css--&gt;</span><br><span class="line">        div &#123;</span><br><span class="line">            height: 100px;</span><br><span class="line">            width: 100px;</span><br><span class="line">            background-color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        @import url(CSS文件地址)</span><br><span class="line">        &lt;!--import方式引入的CSS文件里的代码--&gt;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">2. 以行间样式引入CSS</span><br><span class="line">&lt;div style=&quot;height: 100px;width: 100px;background-color: red;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">3. 引入外部CSS文件（推荐方法）</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;page.css&quot;&gt;</span><br><span class="line">    &lt;!--rel是引入文件与页面之间的关系，</span><br><span class="line">    stylesheet作为当前页面的样式表，</span><br><span class="line">    href是外部资源的地址--&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3.选择器"></a>3.选择器</h2><p>CSS提供了多样的选择器使CSS样式与html结构匹配，有这样一个结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> <span class="attr">id</span>=<span class="string">"only"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"ul-list"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">em</span>&gt;</span>我在这儿<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">strong</span>&gt;</span>我也在这儿<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一行文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>下面就演示下CSS中的选择器。</p><ol><li><p>标签选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">em &#123;</span><br><span class="line">    color: green;  //我在这儿变为绿色</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">    border: 1px solid black; //页面中所有div增加1px边框</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>class选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.header &#123;</span><br><span class="line">    background-color: red; //类名为header的div背景色变为红色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>id选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#only &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 500px;  //id为only的标签有500*500宽高</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通配符选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    margin: 0px;</span><br><span class="line">    padding: 0px;  //页面中所有标签去除内外边距</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>父子选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.header ul li &#123;  //选中类名为header的div下的ul的子元素li</span><br><span class="line">    background-color: blue; </span><br><span class="line">&#125;</span><br><span class="line">//父子选择器查找顺序，从子元素向父元素查找</span><br><span class="line">//先找到li，再筛选出父元素为ul的li，逐级向上查找</span><br></pre></td></tr></table></figure></li><li><p>并列选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li.first &#123; //选中有类名first的li</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分组选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.header span em,</span><br><span class="line">.header span strong &#123; //同时选中div.header下span下的em和strong</span><br><span class="line">    color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>伪类选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为什么叫伪类呢？是因为这个选择器的效果和手动添加一个类名来选择，</span><br><span class="line">效果是一样的。</span><br><span class="line">a:hover &#123;</span><br><span class="line">    background-color: skyblue;</span><br><span class="line">&#125;</span><br><span class="line">//效果和在a标签上添加了一个class=&quot;hover&quot;的类是一样的</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>CSS2.0大致就这七种选择器，CSS3.0又推出了属性选择器，伪元素选择器，条件选择器等</p></blockquote><p>一般来说页面中当然不会只有这么点样式，那么当多个样式同时作用到同一元素时，怎么判断元素最后呈现的样式呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width: 100px;height: 100px;&quot; class=&quot;demo&quot; id=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!--css--&gt;</span><br><span class="line">div &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.demo &#123;</span><br><span class="line">    height: 300px;</span><br><span class="line">    width: 300px;</span><br><span class="line">&#125;</span><br><span class="line">#test &#123;</span><br><span class="line">    height: 400px;</span><br><span class="line">    width: 400px!important;</span><br><span class="line">&#125;</span><br><span class="line">//div最后宽400px高100px</span><br></pre></td></tr></table></figure></p><p>之所以会这样，是因为引入了一个CSS权重的概念，权重值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!important  --  infinity</span><br><span class="line">行间样式  --  1000</span><br><span class="line">id选择器  --  100</span><br><span class="line">属性/class/伪类选择器  --  10</span><br><span class="line">标签/伪元素  --  1</span><br><span class="line">通配符  --  0</span><br><span class="line">//需要判断最终样式时，按照权重值大小判断，越大优先级越高</span><br><span class="line">//当权重值相同时，在样式表中后出现的样式会覆盖先出现的</span><br></pre></td></tr></table></figure></p><h2 id="4-CSS的一些属性"><a href="#4-CSS的一些属性" class="headerlink" title="4.CSS的一些属性"></a>4.CSS的一些属性</h2><p>CSS的属性按照功能可以分为字体文本、边框、背景、盒模型、颜色、定位布局、边距等方面的属性，只简单介绍几种，详细的可以参考手册或是上W3C index查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">font-famliy -- 字体，可以填写多个字体用于兼容</span><br><span class="line">font-size -- 字体大小，默认字体大小16px,网页一般12px</span><br><span class="line">color -- 字体颜色，有三种表示方法，颜色英文单词，十六进制表示，rgb(a)函数表示</span><br><span class="line">text-align -- 文本水平对齐方式</span><br><span class="line">text-indent -- 首行文字缩进</span><br><span class="line">text-decoration -- 文本装饰样式</span><br><span class="line">verticla-align -- 垂直对齐方式（基准线）</span><br><span class="line">letter-spacing -- 文字间隙</span><br><span class="line">word-spacing -- 单词间隙</span><br><span class="line">border -- 边框，这是一个复合属性，由三种属性复合</span><br><span class="line">border-width -- 边框宽度</span><br><span class="line">border-style -- 边框样式(solid,dotted,dashed)</span><br><span class="line">border-color -- 边框颜色</span><br><span class="line">border-left/right/top/bottom -- 单独设置某一边框</span><br><span class="line">background -- 背景，复合属性</span><br><span class="line">background-repeat -- 背景图片没全部填充时是否重复</span><br><span class="line">background-size -- 背景尺寸支持数字、百分比、cover、contain</span><br><span class="line">background-attachment -- 定义背景图随滚动条滚动方式</span><br><span class="line">background-clip -- 背景图片开始绘制区域</span><br><span class="line">display -- 元素展示形式</span><br><span class="line">list-style-type -- 列表元素样式</span><br><span class="line">list-style-position -- 列表标号位置，是在内容器区还是ul内边距区</span><br><span class="line">position -- 定位</span><br><span class="line">visibility -- 可见性</span><br><span class="line">overflow -- 溢出是否隐藏</span><br></pre></td></tr></table></figure></p><blockquote><p>这里仅仅笼统提一下CSS2、3中的属性，CSS布局是前端领域的重难点，建议看看张鑫旭大神的各种奇技淫巧。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;CSS全称Cascading Style Sheet层叠样式表，它的提出是为了解决一开始HTML各种显示功能的发展导致了HTML页面混乱臃肿。CSS的作用是定义HTML等文件的样式，使样式和页面结构分离开，便于之后再次更改样式。就如同html文件是一个涂色本，你可以任意规定某个部分的颜色，页面的表现不在和页面结构相关。CSS的内容主要分为选择器和样式属性。&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>HTML标签简介</title>
    <link href="http://yoursite.com/2017/10/30/HTML%E6%A0%87%E7%AD%BE%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/10/30/HTML标签简介/</id>
    <published>2017-10-30T12:30:19.000Z</published>
    <updated>2018-04-27T02:36:42.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><h2 id="1-文档声明"><a href="#1-文档声明" class="headerlink" title="1. 文档声明"></a>1. 文档声明</h2><p><code>&lt;! DOCUTYPE &gt;</code> （不是一个标签）文档声明头DTD（docutype declaration）有如下几种形式</p><p><em>用于XHTML1.0严格模式的</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE htmlPUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"</span></span><br><span class="line"><span class="meta">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p><em>用于XHTML1.0过渡模式</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE htmlPUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"</span></span><br><span class="line"><span class="meta">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p><p><em>但是现在通用HTML5的文档声明模式</em><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">!DOCUTYPE</span> <span class="attr">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>前几种因为标记语言基于SGML，故需要引入文档类型声明DTD，HTML5没有基于SGML，所以文档声明大大简化了</p><h2 id="2-根标签"><a href="#2-根标签" class="headerlink" title="2.根标签"></a>2.根标签<html></html></h2><p>页面中的其他标签需要放在根标签里</p><h2 id="3-头标签"><a href="#3-头标签" class="headerlink" title="3.头标签"></a>3.头标签<head></head></h2><p><code>&lt;head&gt;&lt;/head&gt;</code>标签，其中可以包含描述页面信息的标签，可用于SEO优化，可包含如下标签</p><p><code>&lt;title&gt;&lt;/title&gt;</code>页面标题</p><p><code>&lt;meta /&gt;</code>提供页面的基本信息，元配置<br>可以设置页面的配置信息，例如<code>charset</code>可以设置页面支持的字符集，避免出现不支持的字符时乱码，charset的字符集必须和文档保存的文件编码类型一致，具体引入<code>utf-8</code>还是<code>gbk2312</code>，考虑加载速度和字符集数量。meta标签也可用于设置页面的关键字内容。</p><p><code>&lt;meta name=&quot;Description&quot; content=&quot;描述内容&quot; /&gt;</code>告诉搜索引擎页面的描述</p><p><code>&lt;meta name=&quot;Keyword&quot; content=&quot;关键字&quot; /&gt;</code>告知页面的关键字</p><p><code>&lt;link /&gt;</code>引入外部资源如css</p><p><code>&lt;script&gt;&lt;/script&gt;</code>包含或者引入js脚本</p><h2 id="4-body标签"><a href="#4-body标签" class="headerlink" title="4.body标签"></a>4.body标签</h2><p><code>&lt;body&gt;&lt;/body&gt;</code>存放页面主要内容，可以配置一些属性，如<code>bgcolor</code>背景色，<code>background</code>背景图片，<code>text</code>文本颜色，<code>topmargin</code>上边距，<code>link</code>超链接默认颜色，<code>alink</code>链接被点击时的颜色，<code>vlink</code>点击完成后的颜色，不过避免这样使用，与web规范违背。</p><h2 id="5-其他语义化标签"><a href="#5-其他语义化标签" class="headerlink" title="5.其他语义化标签"></a>5.其他语义化标签</h2><p>作为一门标记语言，HTML中的标签语义化都十分好，例如<code>&lt;p&gt;&lt;/p&gt;</code>即为paragraph</p><p>按标签元素类型有如下分类：</p><ol><li><p>块级元素：属性为<code>display: block</code>的标签，可以设置宽高，独占一行，不能继承自行级元素，即不能嵌套在行级元素中。块级元素一般来说可以包含任意元素，但是像<code>&lt;p&gt;&lt;/p&gt;</code>标签这样文本级标签，只能包含文字、图片、表单元素等具有文属性的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">常见的几个块级元素：</span><br><span class="line">address -- 地址</span><br><span class="line">blockquote -- 块引用</span><br><span class="line">div -- 最常用的块级容器</span><br><span class="line">form -- 表单</span><br><span class="line">table -- 表格（里面嵌套&lt;tr&gt;和&lt;td&gt;标签）</span><br><span class="line">h1~6 -- 1~6级标题</span><br><span class="line">hr -- 水平线</span><br><span class="line">ol -- 有序列表</span><br><span class="line">ul -- 无序列表</span><br><span class="line">p -- 段落标签</span><br></pre></td></tr></table></figure></li><li><p>行级元素（内联元素）：属性为<code>display: inline</code>的标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">常见的行级元素：</span><br><span class="line">a -- 锚点</span><br><span class="line">em -- 强调</span><br><span class="line">u -- 下划线</span><br><span class="line">cite -- 引用</span><br><span class="line">br -- 换行</span><br><span class="line">i -- 斜体</span><br><span class="line">img -- 图片</span><br><span class="line">label -- 表格标签</span><br><span class="line">span -- 最常用内联容器与div标签类似</span><br><span class="line">input -- 单行文本输入框</span><br><span class="line">textarea -- 多行文本输入框</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>随着web规范的完善，行为样式结构分离的提出，很多标签已经不推荐使用，这些不用得标签可用于自定义标签</p></blockquote><ol start="3"><li>行级块元素：属性为<code>display: inline-block</code>的标签，兼具行级元素与块级元素的特性，不属于默认<code>display</code>属性的一种，使元素本身解析为<code>inline</code>，内部解析成<code>block</code><blockquote><p>tips: 凡是带有inline属性的元素均带有文字属性，元素之间会有4px的间距。</p></blockquote></li></ol><p>按照元素渲染出的盒模型可以分为如下：</p><ol><li>容器级元素： 可以嵌套任意元素</li><li>文本级元素：只能嵌套文本、图片、表单元素。如果在文本级元素中嵌套了块级，则会自动先将文本级元素标签闭合一次，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &lt;div&gt;嘿嘿&lt;/div&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;!--  在页面中会渲染成如下形式 --&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;div&gt;嘿嘿&lt;/div&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="lt-span-gt-amp-lt-div-gt"><a href="#lt-span-gt-amp-lt-div-gt" class="headerlink" title="&lt;span&gt;&amp;&lt;div&gt;"></a><code>&lt;span&gt;</code>&amp;<code>&lt;div&gt;</code></h4><p>这是HTML中重要的两个容器标签，作用相当于抽屉或是收纳盒，可以划分页面具有不同功能的区域，便于存放和操作其他标签，区别是<code>&lt;div&gt;</code>是块级元素，独占一行，<code>&lt;span&gt;</code>行级元素，内容决定其宽高，多用来容纳文字。</p><h4 id="这里需要提一下-lt-a-gt-标签，锚点标签"><a href="#这里需要提一下-lt-a-gt-标签，锚点标签" class="headerlink" title="这里需要提一下&lt;a&gt;标签，锚点标签"></a>这里需要提一下<code>&lt;a&gt;</code>标签，锚点标签</h4><p>这也是HTML中重要的一个标签，<br><code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>属性<code>href</code>意为hypertext reference，超文本引用，可以实现如下功能：</p><ol><li>链接：<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;</code>点击既能跳转到百度。</li><li><p>锚点：<code>href</code>这个用法需要配合<code>name</code>或者<code>id</code>属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;up&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;a href=&quot;#up&quot;&gt;</span><br><span class="line">&lt;!-- 点击a可以定位到div --&gt;</span><br></pre></td></tr></table></figure></li><li><p>协议限定符：<code>href</code>属性还可填写一段javascript代码，点击就执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript: alert(&apos;点击了a&apos;)&quot;&gt;</span><br><span class="line">&lt;!-- 点击会弹出警示框 --&gt;</span><br></pre></td></tr></table></figure></li><li><p>除此之外，<code>href</code>还可实现电话，邮件的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;mailto:邮箱地址&quot;&gt;</span><br><span class="line">&lt;a href=&quot;tel:电话号&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>target</code>属性：规定了打开目标页面的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_self -- 在当前窗口打开</span><br><span class="line">_blank -- 在新窗口打开</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>但是这些功能均可用js实现，故不推荐直接使用</p></blockquote><h4 id="图片标签-lt-img-gt"><a href="#图片标签-lt-img-gt" class="headerlink" title="图片标签&lt;img /&gt;"></a>图片标签<code>&lt;img /&gt;</code></h4><p>这是一个单标签，主要属性<code>src</code>，用于引入图片位置，可填写<em>相对路径</em>，<em>绝对路径</em>，<em>服务器路径</em>，<code>alt</code>属性，图片占位符，用于图片无法显示时提示图片信息，可被搜索引擎爬虫识别</p><p><em>相对路径</em>：和页面相同文件夹目录下的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;one.jpg&quot; /&gt; -- 当前目录下</span><br><span class="line">&lt;img src=&quot;./one.jpg&quot; /&gt; -- 当前目录下</span><br><span class="line">&lt;img src=&quot;images/one.jpg&quot; /&gt; -- 当前目录下images文件夹下</span><br><span class="line">&lt;img src=&quot;../images/one.jpg&quot; -- 上一级目录的images文件夹下</span><br></pre></td></tr></table></figure></p><p><em>绝对路径</em>：图片完整的引用路径<br><code>&lt;img src=&quot;C:/desktop/one.jpg&quot; /&gt;</code></p><p><em>服务器路径</em>：<code>&lt;img src=&quot;/images/one.jpg&quot; /&gt;</code>以imgages为根目录向下寻找</p><h4 id="有序列表，无序列表"><a href="#有序列表，无序列表" class="headerlink" title="有序列表，无序列表"></a>有序列表，无序列表</h4><p>有序列表<code>&lt;ol&gt;&lt;/ol&gt;</code>，无序列表<code>&lt;ul&gt;&lt;/ul&gt;</code>多用来做具有归属关系的功能块、子项，两者区别是子项有无顺序，子项<code>&lt;li&gt;&lt;/li&gt;</code>，可以在<code>&lt;ul&gt;&lt;/ul&gt;</code>上添加<code>type</code>属性实现子项的样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认样式 disc -- 小圆点</span><br><span class="line">square -- 实心正方形</span><br><span class="line">circle -- 空心圆圈</span><br></pre></td></tr></table></figure></p><p>对于有序列表<code>&lt;ol&gt;&lt;/ol&gt;</code>可通过设置<code>type</code>属性来规定排序方式，<code>reversed</code>反向排序，<code>start</code>开始位置</p><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单<form></form></h4><p>表单常用于与后台进行数据传送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">一个简单的账号密码：</span><br><span class="line">&lt;!-- method表示数据传送的方法，有get和post两种，action是数据发送的地址 --&gt;</span><br><span class="line">&lt;form method=&quot;get&quot; action=&quot;#&quot;&gt;</span><br><span class="line">&lt;!--input标签的type属性表示文本类型，text明文，password暗文，name表示数据名，value对应数据值--&gt;</span><br><span class="line">    username: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;填写用户名&quot;&gt;</span><br><span class="line">    password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;确定&quot;&gt;</span><br><span class="line">&lt;!--input的type值为submit时代表这是一个提交按钮，</span><br><span class="line">可配置value属性显示按钮的文字，默认提交，</span><br><span class="line">点击按钮会触发表单的submit事件--&gt;</span><br><span class="line">&lt;!--input的type值还有上传文件的file，</span><br><span class="line">需要搭配form上的属性enctype=&quot;multipart/form-data&quot;</span><br><span class="line">默认情况下，type=&quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--input也可做选择框--&gt;</span><br><span class="line">&lt;form method=&quot;get&quot; action=&quot;#&quot;&gt;</span><br><span class="line">    male:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked&gt;</span><br><span class="line">    female:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;</span><br><span class="line">&lt;!--radio表示单选框，checkbox多选框，设置相同的name表示一组选项，checked默认选中--&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--下拉选择框--&gt;</span><br><span class="line">&lt;form method=&quot;get&quot; action=&quot;#&quot;&gt;</span><br><span class="line">    &lt;select value=&quot;北京&quot;&gt;北京&lt;/select&gt;</span><br><span class="line">    &lt;select value=&quot;上海&quot;&gt;上海&lt;/select&gt;</span><br><span class="line">&lt;!--value才是真实的数据值，默认选中第一个select的内容--&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><h2 id="6-特殊字符"><a href="#6-特殊字符" class="headerlink" title="6.特殊字符"></a>6.特殊字符</h2><p>在HTML中输入多个空格会被折叠为一个空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;嘻      哈哈哈哈&lt;/div&gt;</span><br><span class="line">&lt;!--  渲染到文档中时,多个空格会合并为一个 --&gt;</span><br><span class="line">嘻 哈哈哈哈!</span><br></pre></td></tr></table></figure></p><p>并且，当你想在页面中直接输出一个标签<code>&lt;div&gt;</code>是不行的，浏览器会将它当作HTML渲染，正确的做法是将<code>&lt;</code>用特殊格式表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">举栗子</span><br><span class="line">&amp;nbsp; -- 空格</span><br><span class="line">&amp;gt; -- &gt;号</span><br><span class="line">&amp;lt; -- &lt;号</span><br><span class="line">&amp;amp; -- &amp;</span><br><span class="line">&amp;quot; -- &quot;号</span><br><span class="line">&amp;apos; -- &apos;号</span><br><span class="line">&amp;copy; -- 版权符号 ©</span><br><span class="line">&amp;trade; -- 商标 ™</span><br><span class="line">&amp;#[五位字符unicode码]; -- 可用这种形式输出特定字符</span><br></pre></td></tr></table></figure></p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>HTML的常用标签部分大致就这么些，当然HTML中的标签多种多样，尤其2014年HTML5的推出引入了多种类似<code>&lt;div&gt;</code>但是语义化更加明确的标签，如<code>&lt;header&gt;</code>定义文档头部，<code>&lt;footer&gt;</code>表示文档等页脚，<code>&lt;article&gt;</code>一段文章，<code>&lt;aside&gt;</code>侧边栏，<code>&lt;section&gt;</code>文档的一小节，等等，使页面具有更好的语义和结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTML标签&quot;&gt;&lt;a href=&quot;#HTML标签&quot; class=&quot;headerlink&quot; title=&quot;HTML标签&quot;&gt;&lt;/a&gt;HTML标签&lt;/h1&gt;&lt;h2 id=&quot;1-文档声明&quot;&gt;&lt;a href=&quot;#1-文档声明&quot; class=&quot;headerlink&quot; title=&quot;1. 文档声明&quot;&gt;&lt;/a&gt;1. 文档声明&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;! DOCUTYPE &amp;gt;&lt;/code&gt; （不是一个标签）文档声明头DTD（docutype declaration）有如下几种形式&lt;/p&gt;
&lt;p&gt;&lt;em&gt;用于XHTML1.0严格模式的&lt;/em&gt;&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE htmlPUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>关于前端</title>
    <link href="http://yoursite.com/2017/10/30/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF/"/>
    <id>http://yoursite.com/2017/10/30/关于前端/</id>
    <published>2017-10-30T12:27:09.000Z</published>
    <updated>2018-05-10T02:43:43.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1.名词解释"></a>1.名词解释</h2><p><strong>w3c</strong>: 万维网联盟组织，定制web标准的机构</p><p><strong>SGML</strong>: Stantard Generalized Markup Language标准通用标记语言，定义电子文档结构及描述其内容的语言，是所有电子文档标记语言的起源。</p><p><strong>HTML</strong>: Hypertext Markup language超文本标记语言，采用超链接的方法将不同文档信息组织在一起，显示信息，描述文档语义的语言，语法松散不严格<br><a id="more"></a><br><strong>XML</strong>：Extensible Markup Language可拓展标记语言，用来叙述数据和结构，没有固定标签集，没有语法规则，仅有句法规则（例如标签需要成对）</p><p><strong>XHTML</strong>：Extensible Hypertext Markup Language，可拓展超文本标记语言。<br>因为html书写不规范，在一些设备上容易造成显示问题，出现了严格纯净的html版本，格式与html4.0相似。是HTML和XML的结合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhtml规范：</span><br><span class="line">1.所有标记需要正确嵌套</span><br><span class="line">2.所有标签都需要小写</span><br><span class="line">3.所有标签要正确闭合，单标签写法&lt;br /&gt;，&lt;img src=&quot;/1.jpg&quot; /&gt;</span><br><span class="line">4.属性值加引号</span><br><span class="line">5.属性值需有值</span><br><span class="line">6.在文档开头须有DTD文档类型定义</span><br></pre></td></tr></table></figure><p><strong><em>SEO</em></strong>：Search Engine Optimization，搜索引擎优化，对网站进行调整优化，改变关键字排名。</p><p><strong><em>DTD</em></strong>: Docutype Declaration文档类型定义，是一套关于标记符的语法规则，使文档符合规定的数据交换标准</p><p><strong><em>DHTML</em></strong>：即Dynasmic html动态html，是html,css,js的集合不属于w3c规范</p><p><strong><em>HTTP协议</em></strong>：超文本传输协议，用以规定客户端和服务器传输数据的格式，相似的有SMTP:邮件传输协议，FTP文件传输协议</p><h2 id="2-计算机编码"><a href="#2-计算机编码" class="headerlink" title="2.计算机编码"></a>2.计算机编码</h2><p><strong><em>ASCII</em></strong>：用1字节（8位二进制数）表示一个字符，共有2^8=256个</p><p><strong><em>ANSI</em></strong>：每个国家为了显示本国语言对ASCII码进行扩展，中国GBK2312，日本JIS，台湾BIG5</p><p><strong><em>GBK</em></strong>：对GBK2312的扩展，能够显示少见的以及古汉字</p><p><strong><em>Unicode</em></strong>：用4个字节表示一个字符，但是对ASCII码中存在的字符来说效率低下</p><p><strong><em>GTF-8</em></strong>：(Unicode Transform Format)根据字符不同，采用不同字编码长度，字母1字节，汉字2字节，目前最通用的字符编码格式</p><h3 id="3-HTML颜色值："><a href="#3-HTML颜色值：" class="headerlink" title="3.HTML颜色值："></a>3.HTML颜色值：</h3><p><strong><em>颜色标识符</em></strong>：如blue,red,green</p><p><strong><em>rgb</em></strong>:格式rgb([red], [green], [blue])每一位可用0~255的十进制数表示，也有用rgba格式的，a（alpha）表示透明度，取值范围(0,1)</p><p><strong><em>十六进制表示</em></strong>：<code>#ff4400</code>，每种色值用两位十六进制数表示，当色值两位数一样时可以简写为<code>#f40</code></p><h2 id="3-浏览器组成"><a href="#3-浏览器组成" class="headerlink" title="3.浏览器组成"></a>3.浏览器组成</h2><p>浏览器一般由以下几部分构成：</p><ol><li>用户界面：除了主窗口以外的其他浏览器可见部分</li><li>内核：内核又由如下几个部分组成<ol><li>浏览器引擎：查询操作渲染引擎</li><li>渲染引擎：构建页面的主要引擎，用于解析显示请求回来的文档资源（html和css）</li><li>js解释器：解释执行js</li></ol></li><li>网络：执行网络请求的模块</li><li>数据存储：浏览器用于在客户端硬盘存储诸如cookie等信息的模块<h2 id="4-主流浏览器内核"><a href="#4-主流浏览器内核" class="headerlink" title="4.主流浏览器内核"></a>4.主流浏览器内核</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IE(Internet Explorer):  trident</span><br><span class="line">Google Chrome:  webkit/blink</span><br><span class="line">Safari:  webkit(webkit是谷歌和苹果联合开发)</span><br><span class="line">Firefox:  Gecko</span><br><span class="line">Opera:  presto</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/ASCII.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-名词解释&quot;&gt;&lt;a href=&quot;#1-名词解释&quot; class=&quot;headerlink&quot; title=&quot;1.名词解释&quot;&gt;&lt;/a&gt;1.名词解释&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;w3c&lt;/strong&gt;: 万维网联盟组织，定制web标准的机构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SGML&lt;/strong&gt;: Stantard Generalized Markup Language标准通用标记语言，定义电子文档结构及描述其内容的语言，是所有电子文档标记语言的起源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;: Hypertext Markup language超文本标记语言，采用超链接的方法将不同文档信息组织在一起，显示信息，描述文档语义的语言，语法松散不严格&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
</feed>
