[{"title":"项目记录","date":"2018-07-30T07:43:56.000Z","path":"2018/07/30/项目记录/","text":"本篇记录下最近一次项目的体会及遇到的一些问题。同样也是尝试培养记录的习惯，时常发现以前遇到过的问题、处理过的情况记不清楚，希望能通过博客尽可能的总结一点知识。项目是一个H5的测试题页面，整体效果如下：简介：这是产品推广使用的H5引导页面，根据所选选项生成结果，结果页是由测试题选项分布拼接的海报，做测试题的滚动效果使用插件vue-awesome-swiper，拼接海报使用了插件html2canvas，主要难点在结果页(其他页面暂未要求)要求一屏显示，而设计稿是针对iphone6等机型设计，会出现短屏手机超出一屏，长屏手机不足一屏大量空白的情况。 整体使用vue-cli搭建，分为首页、做题、结果三个路由。因为在移动端触摸事件延迟，使用fastclick插件消除点击延迟，适配问题通过计算屏幕宽度与设计稿宽度比例作为根节点字体大小，使用rem简单适配。顺便一提，在微信浏览器中默认有长按呼出右键菜单(contextmenu)的功能，对我们没什么用，直接禁用。 入口页和做题页首页没有办法严格要求一屏显示，同样因为设计稿图片尺寸问题，因此就直接宽高100%，background-size: contain;使图片完全显示。 做题页面也没遇到什么问题，主要逻辑就是选择后跳到下一题同时记录题号和选项(暂未提供上一题功能)，选项有两种类型：文字和图片，包裹选项的容器则针对选项类型做不同布局。图片选项可以长按放大。 这里讲一下长按放大的实现，长按通过在自定义指令中由touchstart和touchend，判断是否长按，我能想到的有两种思路，一是touchstart时记录起始时间，touchend用当前时间做差；二是touchstart设置定时器，定时器中改变一个开关变量的状态。touchend中检查开关状态，方法自由选择，项目中使用的定时器的方法。再提一下自定义指令传参，若需要传递多个参数或者参数不是简单类型时，最好通过对象的形式传递给binding.value，通过v-test:{a:1,b:2}=”demo”这种形式，binding.arg取得的是字符串形式的值。同时，在绑定指令时，分清楚指令多次绑定会不会对执行产生影响，比如这里，如果使用官方文档中说的绑定简写的形式，会在bind和update这两个钩子函数中执行同样的绑定函数，所以touchstart等事件会注册两次，这就对我们的逻辑造成了影响。一下是项目中使用的指令(其实这里写得乱，选项有点击和长按两种操作，我这里写一块儿了，可以再处理一下)123456789101112131415161718192021222324252627282930313233export const longTouch = &#123; directives: &#123; 'long-touch': &#123; bind: function (el, binding) &#123; let timer = null let cb = binding.value.cb let args = binding.value.args let handle = false el.addEventListener('touchstart', function (e) &#123; if (e.touches.length &gt; 1) return timer = setTimeout(() =&gt; &#123; handle = true cb(true, args) &#125;, 500) &#125;) el.addEventListener('touchmove', function (e) &#123; clearTimeout(timer) e.stopPropagation() handle = true return &#125;) el.addEventListener('touchend', function (e) &#123; clearTimeout(timer) if (!handle) &#123; cb(false, args) &#125; else &#123; handle = false &#125; &#125;) &#125; &#125; &#125;&#125; 函数中做了一定的处理，比如，e.touches这是一个记录屏幕中每个手指动作，在长按时如果屏幕中有多个手指事件则不触发，同样的，如果touchstart后有touchmove也不触发长按，handle用途是决定长按还是点击。长按效果： 再就是计算测试结果的逻辑，拿到的计算规则固定，所以计算函数也比较固定: 这里题号和选项都不多，大体思路是统计五种测试结果对应选项出现的次数再取最高次数的结果，部分代码见下：12345678910111213141516let resultTypeArr = []resultTypeArr.push(&#123; type: 'A', score: this.checked.filter(check =&gt; &#123; let fool = check.index + '' + check.order switch(fool) &#123; case '00': case '10': case '20': case '31': case '41': case '53': return true; &#125; &#125;).length&#125;) 测试结果页测试题页得到的结果通过路由参数传递。结果页分两部分：取得参数后显示对应的结果图并生成二维码(结果图不包含二维码，考虑以后可能二维码会有运营方面的需求，没有写死)、将结果图和二维码定位好后用插件生成海报显示在一屏。123456789101112&lt;div class=\"result-main\"&gt; &lt;div class=\"result-poster common-bg\" ref=\"resultWrap\"&gt; &lt;!-- flex:1部分 --&gt; &lt;div id=\"resultPoster\"&gt; &lt;!-- html2canvas绘制容器 --&gt; &lt;img class=\"poster img-contain\" :src=\"`/static/result$&#123;type&#125;_poster.png`\" alt=\"\" v-if=\"!posterDataUrl\" ref=\"poster\"&gt; &lt;img id=\"qrcodeContent\" :src=\"qrcodeUrl\" v-if=\"!posterDataUrl\" ref=\"qrcodecont\" /&gt; &lt;img v-show=\"posterDataUrl\" :src=\"posterDataUrl\" alt=\"\" id=\"posterImg\" ref=\"finalImg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=\"height: 15vh\"&gt; &lt;!-- 底部按钮 --&gt; &lt;/div&gt;&lt;/div&gt; 最开始使用的方案是利用flex，底部两个按钮和文字提示的部分给高度，海报部分flex:1分配剩余高度,overflow:hidden(具体原理还不清楚，若不加此属性，flex:1的子元素高度超过父容器剩余高度后会挤压给定高度的子元素空间)不添加overflow:添加overflow:接下来就该解决图片显示不全的情况了，一般来说可以通过max-height:100%;max-width:100%使图片自适应容器宽高缩放，但是html2canvas绘制的容器也设置了max-height(否则生成的图片会有空白)，因此对图片使用max-height会失效，我个人只有利用js计算，当图片超出容器高度后设置容器高度100%，解决父子容器同时高度自适应时图片超出容器。剩下就是处理二维码定位，通过计算设计稿和实际图片高度比例利用js实现。 第二个方案类似方案一，方案一是通过flex分配剩余高度，也可以按钮占据容器padding-bottom区域，海报区域height:100%;实现一屏显示，同样由于图片超出高度，需要js计算。 除此之外，html2canvas这个插件还有一点不理解的地方是，在相同html2canvas配置下，同一张图片作为背景图和以img标签引入，经canvas转成图片后清晰度有区别，背景图片时更模糊，大概是源码上的区别吧，还没深究这个问题。当背景图转为canvas模糊我尝试过调整canvas画布宽高与css宽高比例、放大canvas为待绘制容器两倍再缩小canvas、放大待绘制区域宽高为两倍等方法，但是都有大大小小的问题，最后偶然发现利用img标签莫名其妙清晰度就提升了。。。","tags":[{"name":"项目记录","slug":"项目记录","permalink":"http://yoursite.com/tags/项目记录/"}]},{"title":"数据结构与算法js描述总结","date":"2018-05-21T06:33:24.000Z","path":"2018/05/21/数据结构与算法js描述总结/","text":"这篇作用是记录《数据结构与算法javascript描述》一书中的知识点和练习题 数组数组定义是存储元素的线性集合，通过索引（元素地址的偏移量）存取元素 存取函数 查找元素 indexOf()返回参数在数组中的第一个索引 lastIndexOf()返回参数在数组中的最后一个索引 数组字符串形式展示 join()将数组按指定字符连接成字符串 toString()以字符串形式显示数组 由已有数组创建新数组concat()合并两个数组 splice()提取一个数组的子集 可变函数不引用数组中元素就可改变数组内容。 为数组添加元素 push()添加元素到数组末尾 unshift()添加元素到数组开头 从数组中删除元素 pop()删除数组末尾元素 shift()删除数组第一个元素 从数组中间位置添加和删除元素 splice() 为数组排序 reverse() 逆序 降序 sort() 升序 排序时会调用数组元素的toString方法 迭代器方法为数组中每一个元素执行操作 不生成新数组 forEach every some reduce 生成新数组 map filter 数组练习题 列表1. 列表抽象数据类型定义（ADT）列表是一组有序的数据，适用于不需要排序，不是很长的序列。内部使用listSize保存列表元素个数、append在末尾添加元素、insert插入元素、getElement显示当前所在位置的元素，并封装了一系列迭代器方法如下图： 使用pos表示列表当前位置，通过改变这个属性读取列表中不同位置处的值。列表定义的迭代器方法：front end prev next currPos，通过这些方法，可以不关心列表底层的数据存储结构对列表进行遍历，迭代器对访问提供了统一的方式。123for(list.front(); list.currPos() &lt; list.length(); list.next()) &#123; print(list.getElement());&#125; 列表定义及练习题 栈栈是和列表类似的数据结构，区别是栈只允许在列表一端即栈顶添加或删除数据，栈是后入先出(LIFO last-in-first-out)的数据结构。js数组提供了模拟栈操作的方法pop和push。 栈操作 入栈push 出栈pop peek展示栈顶元素 使用top属性记录当前栈顶位置 clear清空栈，方式比较简单粗暴，将top设为0 栈这种先入后出的特性有比较多的应用: 进制转换、判断回文、递归、转换表达式、表达式中括号匹配等。这些还仅仅是书中粗浅的介绍。 栈定义及练习题 队列队列也是一种列表，与栈的区别是只能从一端（队尾）插入元素，从另一端（队首）删除元素。适用于存储有顺序排列的数据，先进先出（First-In-First-Out, FIFO）队列实现和栈差不多，区别是一头进一头出。","tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/tags/数据结构与算法/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"滚动加载优化","date":"2018-05-16T07:50:13.000Z","path":"2018/05/16/滚动加载优化/","text":"优化原因接上一篇滚动加载留的问题。 当列表过长，大量DOM存在于页面之中，当滚动发生时频繁重排造成页面卡顿。 如果列表中每一条包含图片等外部资源，一是加载耗时，二是展示图片需要更多内存，列表过长时卡顿现象更加明显。 优化分析 既然是因为DOM过多造成的影响，那么解决的目的就明晰了，减少DOM数量 对于图片，除了减少页面中的DOM结构以外，还需要针对图片的加载做优化，常见的就是图片懒加载。图片懒加载先来看一个效果，图片比较大，网络不是很好，所以效果比较明显。。。,同时首屏的图片也没有加载。 在图片还未加载时，先用本地图片占位，页面滚动时，判断图片是否到了可见区域，若是，则加载图片同时标记图片已被加载，算了，还是先不说这些，一步步来，首先为什么需要懒加载，懒加载真的有用吗？让我们来看看两张图： 使用图片懒加载： 不使用图片懒加载： 若不使用懒加载，那么同一时间有多少新增图片就发送多少新增请求，而浏览器对于同一个域有并发限制(一般4-8个)，同时服务器为稳定性也对客户端并发数做了限制，如果图片是单独域名下存储还好，但如果是主域名下的静态图片呢？（虽然很少这么干）结果就是在css中使用到的背景图片加载会阻塞其他资源的下载。图片放在单独的域名下不存在阻塞静态资源的问题，但是不能保证用户完整浏览页面的情况下就加载出大量图片，是对带宽的过度占用。总结起来主要就是节省网络带宽，同时避免阻塞时间过长。 了解懒加载的目的后就是怎么落实代码了。当然，还是要先分析一波。 原理分析懒加载，直白点就是图片出现在我们定义的“可视区域”后再加载，在可视区域外的话就是用占位图先占位不加载图片。从代码上来看，需要在滚动时判断图片当前位置是否出现在“可视区域”了，如果出现了，则用Image对象加载图片，在onload事件中再用真实的图片src替换占位图，因为是用Image对象加载完毕后替换，所以效果就是图片会直接展示而不会像网络条件不好时那样一点点刷出来，这样的话，图片会用到两个src一个是占位图，一个是真实的图片地址。真实图片的地址可以使用自定义属性data-存储。同时，已经加载过的图片不需要在滚动时判断是否出现在“可视区域”，可以使用属性来标记图片，这里是unload属性。 代码实现主要的两个函数： 判断是否可见 滚动时遍历元素并判断是否可见，是否需要加载图片。 是否可见123456789let clientHeight = document.body.clientHeightlet th = 300function isVisible(ele) &#123; let pos = ele.getBoundingClientRect() if (pos.bottom &gt;= -th &amp;&amp; pos.top &lt;= clientHeight + th) &#123; return true &#125; return false&#125; 为了直观，这里给出一张图： viewport是body的高度一般是我们浏览器视窗。 getBoundingClientRect得到的是相对viewport的位置数值，在视窗之上数值为负。th是浮动范围，最终定义的可视区域范围就是图中红色区域。 懒加载图片12345678910111213let domCache = el.querySelectorAll('.lazy-load[unload]')function lazyLoad() &#123; domCache.forEach(function (ele) &#123; if (!isVisible(ele) || !ele.getAttribute('unload')) return; ele.removeAttribute('unload') let src = ele.dataset.src let img = new Image() img.onload = function () &#123; ele.src = img.src &#125; img.src = src &#125;)&#125; 其中.lazy-load是图片，unload属性标识图片是否加载过，这里有一处地方需要注意下，if (!isVisible(ele) || !ele.getAttribute(&#39;unload&#39;)) return;，为什么这么在let domCache = el.querySelectorAll(&#39;.lazy-load[unload]&#39;)这个前提下还这么写，主要是因为整体代码是在自定义指令的componentUpdated钩子中编写的，这个钩子会在绑定的元素发生更新（这里就是增加img元素）的时候调用，意味着domCache只会在componentUpdated的时候更新一次，如果不加!ele.getAttribute(&#39;unload&#39;)则加载过的图片还会再次加载（因为domCache不是最新的） ps: 发现语言描述好苍白啊！！ 给出componentUpdated中完整的代码：1234567891011121314151617181920212223242526272829303132componentUpdated(el, binding) &#123; if(!binding.modifiers.lazy) &#123; return &#125; let clientHeight = document.body.clientHeight let th = 300 let domCache = el.querySelectorAll('.lazy-load[unload=\"true\"]') let isVisible let lazyLoad isVisible = function(ele) &#123; let pos = ele.getBoundingClientRect() if (pos.bottom &gt;= -th &amp;&amp; pos.top &lt;= clientHeight + th) &#123; return true &#125; return false &#125; lazyLoad = function() &#123; domCache.forEach(function (ele) &#123; if (!isVisible(ele) || !ele.getAttribute('unload')) return; ele.removeAttribute('unload') let src = ele.dataset.src let img = new Image() img.onload = function () &#123; ele.src = img.src &#125; img.src = src &#125;) &#125; el.onscroll = null el.onscroll = throttle(lazyLoad, 400) lazyLoad()&#125; throttle函数就不再给了，binding.modifiers.lazy是表示是否使用懒加载，以v-load-more.lazy形式使用。需要注意的是componentUpdated更新时调用，所以不将之前绑定的事件解除的话，元素上会绑定大量事件，至于为什么选择onscroll方式绑定，因为这样解绑方便啊。其实还是因为componentUpdated的原因，每次更新都会调用，而throttle函数返回的都是不同的函数。如果非要使用addEventListener，可以在throttle中使用单例模式或者在指令所在js文件中给函数初始化。这里不再示范了，按简单的来。 最后是页面html12345678910&lt;div class=\"test-content\" v-load-more.lazy=\"loadImg\"&gt; &lt;div class=\"flex-wrap\" ref=\"flexWrap\"&gt; &lt;div class=\"img-item\" v-for=\"item in testData\" :key=\"item.name\"&gt; &lt;img class=\"lazy-load\" src=\"../../static/defalut.jpg\" :data-src=\"item.url\" unload=\"true\" alt=\"图片\"&gt; &lt;/div&gt; &lt;div class=\"no-more-content\" v-if=\"loaded\"&gt; &lt;span class=\"no-more-dec\"&gt;没有更多内容了&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","tags":[{"name":"功能","slug":"功能","permalink":"http://yoursite.com/tags/功能/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"初识js","date":"2018-05-16T04:29:21.000Z","path":"2018/05/16/初识js/","text":"初识js这是关于javascript的第一篇文章，还是得好好说说，之后的javascript相关部分就不再废话了，毕竟我是个追求简约的人(￣▽￣)／记不得第一见识javascript是什么时候了，或许是看头条上文章中那些五颜六色的代码块的时候吧，不过那时候并不知道javascript是什么东东，毕竟我以为所有我用的东西都是纯java,c,c++实现的，而这三种语言是没有如此漂亮的代码的。。。后来javascript词频越来越高，也开始慢慢的对javascript有所了解。javascript是一门创造出来解决一些简单前端验证的脚本语言，但是刚开始我也把它和java联系起来，认为javascript和java关系很紧密，当看到它语法时才知道这就像鱼香肉丝和鱼，老婆饼和老婆的关系一样。看到一段小历史才明白这样取名的原因。javascript一开始叫做livescript，是伴随着浏览器netscape navigator出现的一门脚本语言，改名叫做javascript纯粹是新语言为了推广而和当时如日中天的java挂钩。这个名字也就一直延续到了现在，更是迷惑了许多像我这样“鱼香肉丝党”。 js特点 单线程：同一时间只能执行一件任务。 解释性语言：每读到一句js代码就翻译成二进制码执行，导致js运行速度比起编译性语言慢。 事件驱动：js目前主要用于网页中与用户的交互，用户操作鼠标键盘等设备触发页面绑定的事件执行对应的脚本。 弱类型：js中的变量没有java或是c中多样的变量类型，js中的声明的变量可以用于存储任意类型的值，甚至变量不声明也可以使用。 面向对象：js更关注使用对象能做什么，几乎所有操作都是基于对象的，在js中万物皆对象。 跨平台：依托于浏览器的js不用考虑java和c的平台支持，只要是支持js的浏览器，不用关心是什么平台都能运行。 js运行于浏览器处理了一些没必要靠后端处理的数据，减少了许多无意义的网络请求。 动态性：变量在运行时才知道具体是什么类型的值，并且定义的对象原型、方法等都可以重写改变。js通过script标签就可引入到页面中 变量类型 原始值：存储在栈内存中的变量，值不可变。js支持五种原始值类型：Number、String、Boolean、undefined、null。undefined和null只有自身一个值。其中null也算是对象类型，是用于给空对象占位的。 引用值：引用值的存储栈堆配合。栈内存引用堆内存的地址，堆内存中存储引用值的值。三种引用值：Array、Object、Functionjs中的运算符和流控制语句和其他语言别无二致，但是在浏览器环境中，js包括ECMAScript、DOM、BOM。ECMAScript是javascript交由ECMA协会制定的规范浏览器js实现，DOM(Document Object Model)文档对象模型，提供了供脚本操作页面文档对象的接口；BOM(Browser Object Model)提供脚本操作浏览器的接口。以下说的js一般指的是ECMAScript3。 数组js中的数组有别于其他语言，弱数据类型的js允许数组中存储各种类型的数值，并且支持稀松数组，能够越界存取不会报错。 123456//创建一个len长的空数组，以undefined填充new Array(len)// 创建一个元素为x1,x2,x3...的数组new Array(x1,x2,x3...)// 多维数组var arr = [[],[],[]] 运算符js中运算符和c及java没多大区别，都包含逻辑运算符，一元二元运算符等，只不过由于是脚本原因，一些运算符平时不太会用到，比如位运算符。位运算符会将数据转化为二进制数操作，因此速度上会提升不少，位运算符和逻辑运算符相似。 按位非(~)将原数转化成32位的二进制数后对这个二进制数每一位按位取非。 按位与(&amp;)将两个操作数据转换成二进制数后，按两个二进制的每一位进行与操作，两位都是1返回1否则为0。 按位或(|)类似按位与，当两个比较位全为0返回0，否则返回1。 按位异或(^)两个比较位相同时为0，否则为1. 左移(&lt;&lt;)、有符号右移(&gt;&gt;)、无符号右移(&gt;&gt;&gt;)将二进制数进行移位操作，左移不用考虑会以0填充空白位置，有符号右移以符号位填充空白，无符号右移以0填充空白位置。 类型转换js中在操作数据时存在显示类型转换和隐式类型转换。 显示类型转换：通过调用调用一些原生对象将数据转换成所需要的类型，如Number(),String(),Boolean(),toString(),ParseInt(),ParseFloat() 隐式类型转换：isNaN(),一些一元操作符、布尔操作符、关系操作符、相等操作符等操作符时，会发生隐式的类型转换,保证操作符操作的两个数属于同种类型，在大部分数学操作符情况下是数字优先，加性操作符字符串优先，关系和布尔则是布尔值优先。当然有的时候在比较两个值时我们并不希望发生类型转换，这时需要用===操作符。undefined和null在比较中不会发生类型转换，虽然这两者的布尔类型值为0，但是两者与0的关系运算都为false，且规定undefined == null为true，NaN == NaN为false 对象js中一切可操作的东西都是对象，对象有属性的增删改查功能，对象创建推荐使用对象字面量方法，此外还可以通过构造函数创建 函数js中的函数实际也是对象，函数命名推荐小驼峰式写法，创建方法有构造函数、函数声明、函数表达式。有两种函数表达式：命名函数表达式、匿名函数表达式。 命名函数表达式 1var test = function test() &#123;&#125; //后面的test名字可以与前面不同，函数调用时只识别前一个test，后一个test作为字符串在test.name中保存。 匿名函数表达式 1var test = function () &#123;&#125; //和命名函数表达式区别是test.name=test 函数的参数保存在arguments这个类数组中，且形参实参个数可以不对应，当形参实参有映射关系，一个改变，另一个也变。arguments实际是一个对象，含有以下属性： 123arguments.callee //指向当前函数本身，常用于匿名函数调用自身arguments.caller //返回当前函数的调用者，即thisarguments.length //返回当前参数长度 立即执行函数将函数变成表达式可以被()立即执行。一元运算符和逻辑操作符赋值给变量等可以使函数变成表达式 12345678(function (a) &#123; console.log(a);&#125;(1))var aa = function (a) &#123; console.log(a);&#125;(1)//访问aa未定义 构造函数即自定义构造函数 Object(),String(),Array(),Date(),RegExp()等等是js中的内置对象，通过new操作符可以产生对应类型的对象。 自定义构造函数和普通函数没什么区别，只是为了和普通函数区分而认为规定了构造函数采用大驼峰式写法，首字母大写。构造函数简易原理： 在函数体开始的地方创建this对象。 将对应的方法属性保存到this对象上。 隐式返回this当构造函数没有用new操作符时，相当于函数执行，此时this指向运行时的环境。 constructor返回对象的构造函数 包装类包装类是为了避免在对Number,String,Boolean原始值按对象操作时不报错。 12345var num = 123;//隐式new Number(123).say = &apos;123&apos;;num.say = &apos;123&apos;;//进行属性赋值操作后delete Number(123).abc//访问num.say = undefined; 作用域作用域规定了变量能够被访问调用的环境，在函数外声明的变量是全局变量作用域就是全局。在函数中声明的变量作用域是函数及函数嵌套的代码。js中只有函数作用域，没有块级作用域，在for循环中声明的变量全局window也能访问(假设是在全局的for语句)。作用域链是函数保存在[[scope]]属性中的作用域中能够访问的对象的集合，每个函数在被创建时都会将全局对象(GO)放在作用域链的最底端，在函数运行时又会创建一个运行期上下文和一个活跃对象(AO)放在作用域链顶端，定义了函数运行时的环境this,形参等等。函数每一次调用都会产生一个全新的运行期上下文，在函数执行完毕之后函数自己的运行期上下文就被销毁并销毁对AO的引用，查找访问变量时，遵循从上往下原则，优先从活跃对象AO中查找，再顺着作用域链往下查找，若没找到则为未定义。 bind，call，apply可以改变运行时的上下文；with,try-catch会改变作用域链。 闭包当被当作返回值保存到外部的内部函数访问包含它的外部函数的作用域链时会产生闭包，闭包会导致本来应该随着外部函数执行完毕而销毁的AO不被释放而需要更多的内存，因为内部函数包含了外部函数的作用域。这里引用高性能javascript上的一个例子： 123456function assignEvents()&#123; var id = &quot;xdi9592&quot;; document.getElementById(&quot;save-btn&quot;).onclick = function(event)&#123; saveDocument(id); &#125;;&#125; 本应该随着assignEvents执行完毕销毁的assignEvents的AO，因为事件监听中saveDocument还有对AO的引用，导致AO占用的内存没有被释放，产生了内存泄露的问题。合理使用闭包可以创造出很多实用的功能，例如累加器： 12345678910function accumulator() &#123; var count = 0; function add() &#123; count ++; console.log(count); &#125; return add;&#125;var demo = accumulator();demo(); 原型、原型链原型链是作用域链的延伸。原型是一个对象，包含了一些自身属性。在谷歌中如下： 1234function Test() &#123; this.name = &apos;test&apos;;&#125;var test = new Test(); 其中proto是在火狐和chrome中实现的对象(这里是test)的原型属性，标准属性是[[Prototype]]，prototype是函数(这里是test的构造函数Test)的原型。就这样，实例对象的原型proto指向了构造函数的原型Test.prototype，构造函数原型对象Test.prototype的原型Test.prototype.proto指向Object.prototype(并且构造函数还具有constructor属性指向构造器Test函数)。这种指向关系构成了原型链。有了原型链就可以通过在构造函数的原型上添加属性，构造函数的实例对象可以继承构造函数原型上的方法属性。这是js中实现继承的主要方法。 12345678function Test() &#123; this.name = &apos;test&apos;;&#125;Test.prototype.sayName = function() &#123; console.log(this.name);&#125;var test = new Test();test.sayName(); //打印出&apos;test&apos; 使用new创建的对象原型为Object.prototype，构造函数实例化对象的原型为构造函数的prototype,Object.create能够创建指定原型的对象。 js运行机制 语法分析：先将所有代码检查一遍看有无语法错误。 全局预编译： 生成GO对象 变量声明作为GO属性，值为undefined。 函数声明的函数名作为GO属性，值为函数体。 函数预编译： 创建执行期上下文和AO对象。 将形参和变量名作为AO的属性名，值为undefined 传入的实参赋值给形参。 将函数声明的函数名作为AO属性，值为函数体。 未经声明的任何变量都看做是window对象的属性，同时声明的全局变量也是window的属性，区别是未经声明的变量可以delete删除，因为configurable=true，而声明的变量不能通过删除属性的delete删除 本篇完，算是对js的总体认识，之后再对原型继承和数组正则等进行扩充。","tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js类型判断","date":"2018-05-16T04:24:56.000Z","path":"2018/05/16/js类型判断/","text":"js类型判断今天才想起来漏写了类型检测，现在补上。。。 类型检测在js中有6中数据类型：Number,String,Boolean,Null,Undefined,Object。有时候我们需要对值做类型检测，判断是原始值类型还是对象，是何种对象。这篇就总结下类型判断的常见方法。 typeof这是类型判断最基础的方法，能判断出number,string,boolean,undefined,object,function 12345var arr = [1, &apos;1&apos;, false, null, undefined, &#123;num:1&#125;, [1], function()&#123;&#125;];console.log(arr)for(var i = 0, len = arr.length; i &lt; len; i ++) &#123; console.log(typeof(arr[i]));&#125; 可以看到用typeof检测时，将null也视为object，这是因为在以往null是用来给空对象占位的，但是在现在null意为这里不该有值。此外，虽然typeof能将function能将函数类型从object区分出来，但是比如日期对象、数组对象，typeof并不能区分。 Object.prototype.toString通过Object.prototype.toString可以返回一个[Object 类型]字符串。 12345var arr = [1, &apos;1&apos;, false, null, undefined, &#123;num:1&#125;, [1], function()&#123;&#125;];console.log(arr)for(var i = 0, len = arr.length; i &lt; len; i ++) &#123; console.log(Object.prototype.toString.call(arr[i]));&#125; 可以自行试验一下，Object.prototype.toString可以判断几乎所有的数值与对象类型。这里补充一下，直接调用toString方法会返回一个包含this指向的字符串。 123456var obj = &#123;&#125;;console.log(toString(obj));console.log(window.toString(obj));console.log(toString.call(null, obj));console.log(toString(null));console.log(toString(undefined)); instanceofinstanceof判断待检测值原型链上是否有对应构造函数的原型。这并不是一个完善的方法，因为对于原始值类型，并不存在原型。 123456789var obj = &#123;&#125;, arr = [];function fn() &#123;&#125;obj instanceof Object //truearr instanceof Array //truearr instanceof Object //truefn instanceof Function //truearr instanceof Function //falsefn instanceof Object //true 在谷歌控制台中，貌似为声明的对象进行instanceof和算术运算会被转换成空，如下原因虽然还不清楚，但是一般也不会直接在控制台进行操作。本篇完。","tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"初识DOM","date":"2018-05-16T04:18:55.000Z","path":"2018/05/16/初识DOM/","text":"初识DOM前几篇简略的将js的知识复习了一遍，不过还有很多方法、函数式、ES5,6的新特性没概括，之后再补充吧。现在开始了解前端的另一个核心–DOMDOM是Document Object Model的简写，主要功能是用以操作文档，文档能够被操作，是因为在解析页面时将文档结构创建为document对象，html文档中的一个个标签以html节点为根节点构建为有父子结构的树状结构，将文档中的标签转变为可以操作的节点。 针对节点的操作查找节点节点查找常见有以下方法12345678//选出实时变化的元素类数组document.getElementsByTagName()document.getElementsByClassName()document.getElementById()//选出非实时变化的元素类数组document.querySelector()document.querySelectorAll() 添加节点123document.createElement()document.createTextNode()document.createComment() 插入节点1234//注意这两种方法都有剪切作用parent.appendChild(child)//在next前插入preparent.insertBefore(pre,next) 删除节点123//removeChild也有剪切作用，返回被删除节点parent.removeChild(child)child.remove() 替换节点12//new替换origin同时返回originparent.replaceChild(new, origin) document对象上还定义了一些其他属性方法如： 123456document.write() //重写整个文档document.open() //擦除当前文档并新开一个文档document.close() //关闭当前文档document.anchors //文档中锚点的集合document.domain //设置或返回当前文档域名document.title //当前文档标题 节点属性每个节点都可以当作一个对象，提供了大量属性和方法，不仅仅能够操作节点本身，就不一一介绍了。 123456789node.innerHTMLnode.attributesnode.getAttribute()node.setAttribute()node.lastChildnode.nextSiblingnode.offsetHeightnode.parentNodenode.style","tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"盒模型与布局--盒模型篇","date":"2018-05-16T03:58:43.000Z","path":"2018/05/16/盒模型与布局-盒模型篇/","text":"我发现一点一滴的记录似乎对我没有多大意义，莫不如直接看文档，所以索性挑些我遇到的一些重点谈谈。 盒模型html中引入了一个形象的模型–盒模型，来描述html中的元素，不过在说盒模型前，得再次谈谈html中的三种元素类型：block,inline,inline-block。可通过display属性切换，该属性了解以下值： 1display: inline|block|inline-block|table|table-cell|grid|none|inherit; 1. block这是最灵活也是最常用的一种元素类型，典型代表&lt;div&gt;。特征： 可以设置宽高内外边距，宽度默认是父元素100% 元素独占一行12345div&#123; height: 30px; background-color: red;&#125;&lt;div&gt;我是块&lt;/div&gt; 注意四周留出的空白，这是body的默认样式margin: 8px; 2.inline代表：&lt;span&gt;，特征： 不可以设置宽高,内外边距能否设置视情况而定 内容决定了占据大小 和其他元素在同一行排列1234567span&#123; width: 100px; height: 100px; background: green;&#125;&lt;span&gt;我是行级&lt;/span&gt;&lt;span&gt;我是行级&lt;/span&gt; 可以看到设置的宽高并没有生效，并且两个元素之间出现了间隙。之所以产生间隙，这也是行级元素的特性之一，拥有文本特性，即元素之间的空格、换行、tab会导致元素之间产生间隙，这个间隙是由父元素的font-size属性决定的。解决办法也有多种： 最简单直接就是使元素之间没有空格，但是这些方法对于多个标签操作太麻烦了 12345678910使元素不换行- &lt;span&gt;我是行级&lt;/span&gt;&lt;span&gt;我是行级&lt;/span&gt;注释空格- &lt;span&gt;我是行级&lt;/span&gt;&lt;!----&gt;&lt;span&gt;我是行级&lt;/span&gt;使用margin: -4px;- span&#123; &lt;!-- ... --&gt; margin: -4px; //取决于字体大小&#125; 使父元素font-size: 0; 123456.spanparent &#123; font-size: 0;&#125;.spanparent span &#123; font-size: 14px;&#125; 运用css属性letter-spacing或者word-spacing，不过还是得根据字体大小设定 12345678.spanparent &#123; letter-spacing: -4px; /*word-spacing: -4px;*/&#125;.spanparent span &#123; letter-spacing: 0; /*word-spacing: 0;*/&#125; 再说边距的问题html元素还可分为替换元素和非替换元素，行内元素能否设置边距就与这两者相关 非替换元素：内容包含在标签中，如&lt;span&gt; &lt;p&gt; 替换元素：内容由外部引入，不在标签之中，如&lt;img&gt; &lt;input&gt;那么问题来了，前面为什么说行级元素能否设置内外边距视情况而定呢？这就是原因。对于非替换元素，可以理解为只有水平方向上的边距是有作用的。而对于替换元素，则可以像块级元素一样设置内外边距宽高。看个例子，页面结构如下：123456&lt;div class=\"test\"&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;span class=\"span1\"&gt;我是行级.span1&lt;/span&gt; &lt;span class=\"span2\"&gt;我是行级.span2&lt;/span&gt;&lt;/div&gt;&lt;input type=\"text\" value=\"这是个输入框\"&gt; 样式表123456789101112131415161718192021222324252627* &#123; margin: 0; padding: 0;&#125;.span1 &#123; width: 100px; height: 100px; padding: 0 30px; margin: 0 30px; background: green;&#125;input &#123; width: 100px; height: 100px; background: yellow; padding: 30px; margin: 30px;&#125;.span2 &#123; padding-top: 30px; background: blue; margin: 30px 0;&#125;.test &#123; height: 100px; background: black;&#125; 结果如图：可以看到.span1确实有左右margin和padding，且忽略的设置的宽高，可替换元素input能够像块级元素一样操作，但是等等，再看中间的.span2，这就是所谓的非替换元素设置垂直方向的边距失效，虽然视觉上有效果，但是.span2的上内边距并没有起到占位的作用，不会对其他元素造成影响（但是为什么要这么做还不太清楚）。总而言之，给非替换元素设置垂直方向边距是无效的。 3.inline-block这不是默认display属性的一种，但是可配置，使元素同时具有行级和块级的特性（说起来挺像行级替换元素） 4.其他其他类型的display属性值就不再详细介绍：display: none隐藏元素，display: inherit属性由父元素继承来，display: table搭配display: table-cell等可以做到类似css3中flex弹性盒子的效果。 display: grid这是一种类似table布局的新css属性，主要搭配如下几个属性实现网格布局： 123456789定义每行的高度，行间距grid-template-rows: rowheight1 rowmargin1 rowheight2 rowmargin2 rowheight3;定义每列宽度间距grid-template-columns: colwidth1 colmargin1 colwidth2 colmargin2 colwidth3;定义单元格位置grid-column: start/end;grid-row: start/end;或者以这种复合形式grid-area: rowstart/colstart/rowend/colend; 盒模型从这儿开始上面介绍的是元素的类型，从这里开始正式的介绍我们的主角–盒模型（元素框）。盒模型是文档中用于布局的主要模型，可以理解为HTML元素的化身，描述了元素在文档中的大小及位置，我们以&lt;div&gt;为例。如图就是一个盒模型的结构，包含content,padding,border,margin四部分，对于有定位的元素还有position用于描述元素的位置。盒模型又分为w3c标准盒模型以及IE盒模型，区别是对盒子宽高的定义 w3c标准盒模型： 12width = contentWidthheight = contentHeight IE盒模型 1height/width = content + padding + border 从以上公式可以看出区别，w3c标准盒模型中，设定的宽度为内容区宽度，而IE盒模型中，设置的宽度被内容区、内边距、边框共同占用。 文档声明头doctype规定了浏览器以w3c标准解释盒模型，若没有声明，则看浏览器厂商的心情了。可以设置box-sizing: border-box;按照IE盒模型解释，默认content-box，个人觉得IE盒模型似乎更好用些。。。 block-level-box&amp;inline-level-box以上是盒模型的简介，众所周知，元素分为块级元素和行级元素，那么这两种元素是如何依据盒模型体现在布局渲染中的呢？这就引入了块级盒&amp;行级盒。一般块级元素会生成块级盒，行级元素生成行级盒。特性已经在上面display: block|inline描述过了。 元素会根据display属性来决定以何种上下文规则渲染(BFC、IFC属于FC(Formatting Context)，是一套盒子的渲染方式，下一篇讲)，我对盒模型和格式化上下文的理解比较混乱，还得多学习啊！","tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"DOM","slug":"DOM","permalink":"http://yoursite.com/tags/DOM/"}]},{"title":"移动端滚动加载","date":"2018-05-14T08:53:34.000Z","path":"2018/05/14/移动端滚动加载/","text":"开头最近没什么事情，得以有空实现一个小功能。移动端滚动加载是比较常见的需求，类似这样，样式将就看看，不是重点 首先分析一下实现这个效果需要做些什么： 布局上：导航吸底再就是滚动区域 滚动功能：根据滚动距离执行加载逻辑下面就这两个方向实现我们的功能。 布局对于布局，我一开始是想的这两种写法 盒模型是border-box基础上 方法一1234&lt;div id=\"app\"&gt; &lt;div class=\"scroll-content\"&gt;&lt;/div&gt; &lt;div class=\"tabs\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.scroll-content &#123; /* ... */ height: 90vh; margin-bottom: 10vh; overflow-y: scroll; -webkit-overflow-scrolling: touch;&#125;.tabs &#123; /* ... */ position: absolute; bottom: 0; height: 10vh;&#125; 方法二12345.scroll-content &#123; /* ... */ height: 100%; padding-bottom: 10vh;&#125; 这个-webkit-overflow-scrolling: touch是为了解决在ios中滚动卡顿没有弹性滚动的问题，还有吸底为什么不用fixed呢？因为在移动端它的表现不是很好，可能会出现滚动时元素抖动的情况。观察滚动条滚动行为可以知道，采用方案二会导致滚动条滚动到被tabs覆盖的区域，故不采用，那么方案一呢？乍看是没有问题，但是测试的时候发现，在ios下尤其ipad，出现些让人脑壳疼的后果，有-webkit-overflow-scrolling后，滚动区域会遮住底部导航,除非将滚动元素放在导航区域的前面(尚没追究具体原因，大概和层级有关)，因此也没有采用这种方式。最后按如下布局：123456&lt;div id=\"app\"&gt; &lt;div class=\"scroll-wrapper\"&gt; &lt;div class=\"scroll-content\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"tabs\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.scroll-wrapper &#123; /* ... */ height: 100%; padding-bottom: 10vh; overflow: hidden;&#125;.scroll-content &#123; /* ... */ height: 100%; overflow-y: scroll; -webkit-overflow-scrolling: touch; -webkit-tap-highlight-color: rgba(255, 255, 255, 0)&#125; scroll-content利用height: 100%占满父容器剩余高度，其中-webkit-tap-highlight-color属性是为了避免在ios下点击元素出现灰色背景。布局大概就是这样，具体细节再调整。 滚动功能滚动可能第一时间想到的是scroll事件，确实，但是网上有的帖子说在ios中，scroll会出现只有滚动停止后才触发scroll事件的问题，貌似是因为之前的ios版本中，苹果对第三方的浏览器内核做了限制，最终导致这个问题，不过我并没有复现，但是还是主要使用touchmove事件来做滚动吧。再进一步分析，touchmove和scroll事件都是高频触发的，但是我们的需求并不需要太高的触发频率，这里采用节流函数，如下：12345678910function throttle(fn, delay = 300) &#123; let prevTime = new Date() return function (...args) &#123; let newTime = new Date() if(newTime - prevTime &gt; delay) &#123; fn.apply(this, args) prevTime = newTime &#125; &#125;&#125; 没使用防抖是因为节流更符合我们的场景，除非每次手指滚动的过程比较短促，否则防抖会影响加载事件的触发。不过接下来这个场景会用到防抖（当然也可以使用节流，不过节流有时候会出现问题，之后会说，这里还是使用防抖介绍一下吧）。先看一个效果，也就是之前针对ios添加的-webkit-overflow-scrolling在滚动手势结束后，页面还会依惯性滚动一段距离，我希望在惯性滚动过程也检测是否需要执行加载逻辑，有以下几种方案： 使用节流，按一定频率定时触发检测 使用防抖，在滚动开始及结束后检测 防抖节流搭配使用，固定频率检测+滚动结束后检测分析：方案一，一般情况下表现正常，但是如果惯性滚动加速度过大，第一次检测后马上就滚动到底部，delay时间内就完成了整个滚动行为，加载函数不能正常执行方案二，缺点也比较明显，滚动完成后需要等待delay时间才执行检测函数，其实性能来说是方案二最优，但是体验不太好。那么就采用方案三，以下是更改后的节流函数：123456789101112131415161718192021function throttle(fn, delay = 300) &#123; let prevTime = new Date() let timer = null let timeOutFn return function (...args) &#123; let newTime = new Date() timeOutFn = timeOutFn ? timeOutFn : () =&gt; &#123; clearTimeout(timer) timer = null fn.apply(this, args) &#125; clearTimeout(timer) timer = null if(newTime - prevTime &gt;= delay) &#123; fn.apply(this, args) prevTime = newTime &#125; else &#123; timer = setTimeout(timeOutFn, 150) &#125; &#125;&#125; 这个功能是基于vue指令完成的，因为需要获取元素的滚动位置，所以选择在inserted钩子中编写代码：1234567891011&lt;div ref=\"fofo\" class=\"load-wrapper\"&gt; &lt;div class=\"test-content\" v-load-more=\"loading\"&gt; &lt;div class=\"test-item\" v-for=\"item in testData\" :key=\"item.key\"&gt; &lt;div class=\"left-area\" :style=\"item.styleObj\"&gt;&#123;&#123;item.item&#125;&#125;&lt;/div&gt; &lt;div class=\"right-area\"&gt;&#123;&#123;item.content&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"no-more-content\" v-if=\"loaded\"&gt; &lt;span class=\"no-more-dec\"&gt;没有更多内容了&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 模拟加载函数1234567891011121314151617181920loading() &#123; let _this = this if(this.isLoading || this.loaded) &#123; return; &#125; console.log('is loading') this.isLoading = true this.startNum ++ let timer = setTimeout(function() &#123; let tempArr = _this.genData() _this.testData = _this.testData.concat(tempArr) clearTimeout(timer) timer = null _this.isLoading = false if(_this.startNum == 5) &#123; _this.loaded = true &#125; console.log('loaded') &#125;, 500)&#125; 指令通过mixins混合123456789101112131415161718192021222324252627282930import &#123; debounce, throttle &#125; from './tools'export const loadMore = &#123; directives: &#123; 'load-more': &#123; inserted(el, binding) &#123; let elHeight = el.clientHeight let elInnerHTML = el.innerHTML let fn = binding.value let elScrollHeight let elScrollTop let checkScroll let callback checkScroll = function () &#123; elScrollTop = el.scrollTop elScrollHeight = el.scrollHeight return elScrollHeight - elHeight - elScrollTop &lt;= 100 &#125; callback = function () &#123; if (checkScroll()) &#123; fn() &#125; &#125; el.addEventListener('touchmove', throttle(callback, 300), false) el.addEventListener('scroll', throttle(callback, 200), false) &#125; &#125; &#125;&#125;偷了个懒，同时绑定了touchmove和scroll事件 效果是有了，并且表现正常，但是想想，当列表很长的时候，页面中新增大量DOM和图片加载的时候滚动时卡顿就会比较明显了，那怎么优化呢？这就是下一篇的内容了。","tags":[{"name":"功能","slug":"功能","permalink":"http://yoursite.com/tags/功能/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/优化/"}]},{"title":"说明","date":"2018-05-10T02:26:50.000Z","path":"2018/05/10/说明/","text":"这是一篇说明非常悲伤，以前写的博客没有及时备份，过年电脑出问题后就只剩下最初的三篇了。但是问题不大，以后多注意下备份，千万别再出问题了。好在之前把博客离线了下来，但是离线也出了问题，最终还是只拯救回来四篇。。。","tags":[{"name":"杂项","slug":"杂项","permalink":"http://yoursite.com/tags/杂项/"}]},{"title":"CSS简介","date":"2017-10-30T12:30:35.000Z","path":"2017/10/30/CSS简介/","text":"1.简介CSS全称Cascading Style Sheet层叠样式表，它的提出是为了解决一开始HTML各种显示功能的发展导致了HTML页面混乱臃肿。CSS的作用是定义HTML等文件的样式，使样式和页面结构分离开，便于之后再次更改样式。就如同html文件是一个涂色本，你可以任意规定某个部分的颜色，页面的表现不在和页面结构相关。CSS的内容主要分为选择器和样式属性。 2.CSS引入一般CSS有三种引入页面的方式：1234567891011121314151617181920212223242526271. 页面级css&lt;head&gt; &lt;style type=&quot;text/css&quot;&gt;&lt;!--style的type属性规定了文件的数据类型(MIME)，这儿type只有唯一值text/css，现在可以忽略type属性，style标签的默认type类型为text/css--&gt; div &#123; height: 100px; width: 100px; background-color: red; &#125; @import url(CSS文件地址) &lt;!--import方式引入的CSS文件里的代码--&gt; &lt;/style&gt;&lt;/head&gt;2. 以行间样式引入CSS&lt;div style=&quot;height: 100px;width: 100px;background-color: red;&quot;&gt;&lt;/div&gt;3. 引入外部CSS文件（推荐方法）&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;page.css&quot;&gt; &lt;!--rel是引入文件与页面之间的关系， stylesheet作为当前页面的样式表， href是外部资源的地址--&gt;&lt;/head&gt; 3.选择器CSS提供了多样的选择器使CSS样式与html结构匹配，有这样一个结构：12345678910111213141516&lt;div class=\"container\" id=\"only\"&gt; &lt;div class=\"header\"&gt; &lt;ul class=\"ul-list\"&gt; &lt;li class=\"first\"&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt; &lt;/ul&gt; &lt;span&gt; &lt;em&gt;我在这儿&lt;/em&gt; &lt;strong&gt;我也在这儿&lt;/strong&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;p&gt;这是一行文本&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 下面就演示下CSS中的选择器。 标签选择器 123456em &#123; color: green; //我在这儿变为绿色&#125;div &#123; border: 1px solid black; //页面中所有div增加1px边框&#125; class选择器 123.header &#123; background-color: red; //类名为header的div背景色变为红色&#125; id选择器 1234#only &#123; width: 500px; height: 500px; //id为only的标签有500*500宽高&#125; 通配符选择器 1234* &#123; margin: 0px; padding: 0px; //页面中所有标签去除内外边距&#125; 父子选择器 12345.header ul li &#123; //选中类名为header的div下的ul的子元素li background-color: blue; &#125;//父子选择器查找顺序，从子元素向父元素查找//先找到li，再筛选出父元素为ul的li，逐级向上查找 并列选择器 123li.first &#123; //选中有类名first的li background-color: yellow;&#125; 分组选择器 1234.header span em,.header span strong &#123; //同时选中div.header下span下的em和strong color: pink;&#125; 伪类选择器 123456为什么叫伪类呢？是因为这个选择器的效果和手动添加一个类名来选择，效果是一样的。a:hover &#123; background-color: skyblue;&#125;//效果和在a标签上添加了一个class=&quot;hover&quot;的类是一样的 CSS2.0大致就这七种选择器，CSS3.0又推出了属性选择器，伪元素选择器，条件选择器等 一般来说页面中当然不会只有这么点样式，那么当多个样式同时作用到同一元素时，怎么判断元素最后呈现的样式呢123456789101112131415&lt;div style=&quot;width: 100px;height: 100px;&quot; class=&quot;demo&quot; id=&quot;test&quot;&gt;&lt;/div&gt;&lt;!--css--&gt;div &#123; height: 200px; width: 200px;&#125;.demo &#123; height: 300px; width: 300px;&#125;#test &#123; height: 400px; width: 400px!important;&#125;//div最后宽400px高100px 之所以会这样，是因为引入了一个CSS权重的概念，权重值如下：12345678!important -- infinity行间样式 -- 1000id选择器 -- 100属性/class/伪类选择器 -- 10标签/伪元素 -- 1通配符 -- 0//需要判断最终样式时，按照权重值大小判断，越大优先级越高//当权重值相同时，在样式表中后出现的样式会覆盖先出现的 4.CSS的一些属性CSS的属性按照功能可以分为字体文本、边框、背景、盒模型、颜色、定位布局、边距等方面的属性，只简单介绍几种，详细的可以参考手册或是上W3C index查找。12345678910111213141516171819202122232425font-famliy -- 字体，可以填写多个字体用于兼容font-size -- 字体大小，默认字体大小16px,网页一般12pxcolor -- 字体颜色，有三种表示方法，颜色英文单词，十六进制表示，rgb(a)函数表示text-align -- 文本水平对齐方式text-indent -- 首行文字缩进text-decoration -- 文本装饰样式verticla-align -- 垂直对齐方式（基准线）letter-spacing -- 文字间隙word-spacing -- 单词间隙border -- 边框，这是一个复合属性，由三种属性复合border-width -- 边框宽度border-style -- 边框样式(solid,dotted,dashed)border-color -- 边框颜色border-left/right/top/bottom -- 单独设置某一边框background -- 背景，复合属性background-repeat -- 背景图片没全部填充时是否重复background-size -- 背景尺寸支持数字、百分比、cover、containbackground-attachment -- 定义背景图随滚动条滚动方式background-clip -- 背景图片开始绘制区域display -- 元素展示形式list-style-type -- 列表元素样式list-style-position -- 列表标号位置，是在内容器区还是ul内边距区position -- 定位visibility -- 可见性overflow -- 溢出是否隐藏 这里仅仅笼统提一下CSS2、3中的属性，CSS布局是前端领域的重难点，建议看看张鑫旭大神的各种奇技淫巧。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"HTML标签简介","date":"2017-10-30T12:30:19.000Z","path":"2017/10/30/HTML标签简介/","text":"HTML标签1. 文档声明&lt;! DOCUTYPE &gt; （不是一个标签）文档声明头DTD（docutype declaration）有如下几种形式 用于XHTML1.0严格模式的12&lt;!DOCTYPE htmlPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt; 用于XHTML1.0过渡模式12&lt;!DOCTYPE htmlPUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; 但是现在通用HTML5的文档声明模式1&lt;!DOCUTYPE html&gt; 前几种因为标记语言基于SGML，故需要引入文档类型声明DTD，HTML5没有基于SGML，所以文档声明大大简化了 2.根标签页面中的其他标签需要放在根标签里 3.头标签&lt;head&gt;&lt;/head&gt;标签，其中可以包含描述页面信息的标签，可用于SEO优化，可包含如下标签 &lt;title&gt;&lt;/title&gt;页面标题 &lt;meta /&gt;提供页面的基本信息，元配置可以设置页面的配置信息，例如charset可以设置页面支持的字符集，避免出现不支持的字符时乱码，charset的字符集必须和文档保存的文件编码类型一致，具体引入utf-8还是gbk2312，考虑加载速度和字符集数量。meta标签也可用于设置页面的关键字内容。 &lt;meta name=&quot;Description&quot; content=&quot;描述内容&quot; /&gt;告诉搜索引擎页面的描述 &lt;meta name=&quot;Keyword&quot; content=&quot;关键字&quot; /&gt;告知页面的关键字 &lt;link /&gt;引入外部资源如css &lt;script&gt;&lt;/script&gt;包含或者引入js脚本 4.body标签&lt;body&gt;&lt;/body&gt;存放页面主要内容，可以配置一些属性，如bgcolor背景色，background背景图片，text文本颜色，topmargin上边距，link超链接默认颜色，alink链接被点击时的颜色，vlink点击完成后的颜色，不过避免这样使用，与web规范违背。 5.其他语义化标签作为一门标记语言，HTML中的标签语义化都十分好，例如&lt;p&gt;&lt;/p&gt;即为paragraph 按标签元素类型有如下分类： 块级元素：属性为display: block的标签，可以设置宽高，独占一行，不能继承自行级元素，即不能嵌套在行级元素中。块级元素一般来说可以包含任意元素，但是像&lt;p&gt;&lt;/p&gt;标签这样文本级标签，只能包含文字、图片、表单元素等具有文属性的内容 1234567891011常见的几个块级元素：address -- 地址blockquote -- 块引用div -- 最常用的块级容器form -- 表单table -- 表格（里面嵌套&lt;tr&gt;和&lt;td&gt;标签）h1~6 -- 1~6级标题hr -- 水平线ol -- 有序列表ul -- 无序列表p -- 段落标签 行级元素（内联元素）：属性为display: inline的标签 123456789101112常见的行级元素：a -- 锚点em -- 强调u -- 下划线cite -- 引用br -- 换行i -- 斜体img -- 图片label -- 表格标签span -- 最常用内联容器与div标签类似input -- 单行文本输入框textarea -- 多行文本输入框 随着web规范的完善，行为样式结构分离的提出，很多标签已经不推荐使用，这些不用得标签可用于自定义标签 行级块元素：属性为display: inline-block的标签，兼具行级元素与块级元素的特性，不属于默认display属性的一种，使元素本身解析为inline，内部解析成block tips: 凡是带有inline属性的元素均带有文字属性，元素之间会有4px的间距。 按照元素渲染出的盒模型可以分为如下： 容器级元素： 可以嵌套任意元素 文本级元素：只能嵌套文本、图片、表单元素。如果在文本级元素中嵌套了块级，则会自动先将文本级元素标签闭合一次，例如：1234567&lt;p&gt; &lt;div&gt;嘿嘿&lt;/div&gt;&lt;/p&gt;&lt;!-- 在页面中会渲染成如下形式 --&gt;&lt;p&gt;&lt;/p&gt;&lt;div&gt;嘿嘿&lt;/div&gt;&lt;p&gt;&lt;/p&gt; &lt;span&gt;&amp;&lt;div&gt;这是HTML中重要的两个容器标签，作用相当于抽屉或是收纳盒，可以划分页面具有不同功能的区域，便于存放和操作其他标签，区别是&lt;div&gt;是块级元素，独占一行，&lt;span&gt;行级元素，内容决定其宽高，多用来容纳文字。 这里需要提一下&lt;a&gt;标签，锚点标签这也是HTML中重要的一个标签，&lt;a href=&quot;&quot;&gt;&lt;/a&gt;属性href意为hypertext reference，超文本引用，可以实现如下功能： 链接：&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击既能跳转到百度。 锚点：href这个用法需要配合name或者id属性： 123&lt;div id=&quot;up&quot;&gt;&lt;/div&gt;&lt;a href=&quot;#up&quot;&gt;&lt;!-- 点击a可以定位到div --&gt; 协议限定符：href属性还可填写一段javascript代码，点击就执行 12&lt;a href=&quot;javascript: alert(&apos;点击了a&apos;)&quot;&gt;&lt;!-- 点击会弹出警示框 --&gt; 除此之外，href还可实现电话，邮件的功能 12&lt;a href=&quot;mailto:邮箱地址&quot;&gt;&lt;a href=&quot;tel:电话号&quot;&gt; target属性：规定了打开目标页面的方式 12_self -- 在当前窗口打开_blank -- 在新窗口打开 但是这些功能均可用js实现，故不推荐直接使用 图片标签&lt;img /&gt;这是一个单标签，主要属性src，用于引入图片位置，可填写相对路径，绝对路径，服务器路径，alt属性，图片占位符，用于图片无法显示时提示图片信息，可被搜索引擎爬虫识别 相对路径：和页面相同文件夹目录下的路径1234&lt;img src=&quot;one.jpg&quot; /&gt; -- 当前目录下&lt;img src=&quot;./one.jpg&quot; /&gt; -- 当前目录下&lt;img src=&quot;images/one.jpg&quot; /&gt; -- 当前目录下images文件夹下&lt;img src=&quot;../images/one.jpg&quot; -- 上一级目录的images文件夹下 绝对路径：图片完整的引用路径&lt;img src=&quot;C:/desktop/one.jpg&quot; /&gt; 服务器路径：&lt;img src=&quot;/images/one.jpg&quot; /&gt;以imgages为根目录向下寻找 有序列表，无序列表有序列表&lt;ol&gt;&lt;/ol&gt;，无序列表&lt;ul&gt;&lt;/ul&gt;多用来做具有归属关系的功能块、子项，两者区别是子项有无顺序，子项&lt;li&gt;&lt;/li&gt;，可以在&lt;ul&gt;&lt;/ul&gt;上添加type属性实现子项的样式：123默认样式 disc -- 小圆点square -- 实心正方形circle -- 空心圆圈 对于有序列表&lt;ol&gt;&lt;/ol&gt;可通过设置type属性来规定排序方式，reversed反向排序，start开始位置 表单表单常用于与后台进行数据传送12345678910111213141516171819202122232425262728一个简单的账号密码：&lt;!-- method表示数据传送的方法，有get和post两种，action是数据发送的地址 --&gt;&lt;form method=&quot;get&quot; action=&quot;#&quot;&gt;&lt;!--input标签的type属性表示文本类型，text明文，password暗文，name表示数据名，value对应数据值--&gt; username: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;填写用户名&quot;&gt; password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;确定&quot;&gt;&lt;!--input的type值为submit时代表这是一个提交按钮，可配置value属性显示按钮的文字，默认提交，点击按钮会触发表单的submit事件--&gt;&lt;!--input的type值还有上传文件的file，需要搭配form上的属性enctype=&quot;multipart/form-data&quot;默认情况下，type=&quot;application/x-www-form-urlencoded&quot;&lt;/form&gt;&lt;!--input也可做选择框--&gt;&lt;form method=&quot;get&quot; action=&quot;#&quot;&gt; male:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked&gt; female:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;&lt;!--radio表示单选框，checkbox多选框，设置相同的name表示一组选项，checked默认选中--&gt;&lt;/form&gt;&lt;!--下拉选择框--&gt;&lt;form method=&quot;get&quot; action=&quot;#&quot;&gt; &lt;select value=&quot;北京&quot;&gt;北京&lt;/select&gt; &lt;select value=&quot;上海&quot;&gt;上海&lt;/select&gt;&lt;!--value才是真实的数据值，默认选中第一个select的内容--&gt;&lt;/form&gt; 6.特殊字符在HTML中输入多个空格会被折叠为一个空格：123&lt;div&gt;嘻 哈哈哈哈&lt;/div&gt;&lt;!-- 渲染到文档中时,多个空格会合并为一个 --&gt;嘻 哈哈哈哈! 并且，当你想在页面中直接输出一个标签&lt;div&gt;是不行的，浏览器会将它当作HTML渲染，正确的做法是将&lt;用特殊格式表示：12345678910举栗子&amp;nbsp; -- 空格&amp;gt; -- &gt;号&amp;lt; -- &lt;号&amp;amp; -- &amp;&amp;quot; -- &quot;号&amp;apos; -- &apos;号&amp;copy; -- 版权符号 ©&amp;trade; -- 商标 ™&amp;#[五位字符unicode码]; -- 可用这种形式输出特定字符 结语HTML的常用标签部分大致就这么些，当然HTML中的标签多种多样，尤其2014年HTML5的推出引入了多种类似&lt;div&gt;但是语义化更加明确的标签，如&lt;header&gt;定义文档头部，&lt;footer&gt;表示文档等页脚，&lt;article&gt;一段文章，&lt;aside&gt;侧边栏，&lt;section&gt;文档的一小节，等等，使页面具有更好的语义和结构。","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"关于前端","date":"2017-10-30T12:27:09.000Z","path":"2017/10/30/关于前端/","text":"1.名词解释w3c: 万维网联盟组织，定制web标准的机构 SGML: Stantard Generalized Markup Language标准通用标记语言，定义电子文档结构及描述其内容的语言，是所有电子文档标记语言的起源。 HTML: Hypertext Markup language超文本标记语言，采用超链接的方法将不同文档信息组织在一起，显示信息，描述文档语义的语言，语法松散不严格XML：Extensible Markup Language可拓展标记语言，用来叙述数据和结构，没有固定标签集，没有语法规则，仅有句法规则（例如标签需要成对） XHTML：Extensible Hypertext Markup Language，可拓展超文本标记语言。因为html书写不规范，在一些设备上容易造成显示问题，出现了严格纯净的html版本，格式与html4.0相似。是HTML和XML的结合 1234567xhtml规范：1.所有标记需要正确嵌套2.所有标签都需要小写3.所有标签要正确闭合，单标签写法&lt;br /&gt;，&lt;img src=&quot;/1.jpg&quot; /&gt;4.属性值加引号5.属性值需有值6.在文档开头须有DTD文档类型定义 SEO：Search Engine Optimization，搜索引擎优化，对网站进行调整优化，改变关键字排名。 DTD: Docutype Declaration文档类型定义，是一套关于标记符的语法规则，使文档符合规定的数据交换标准 DHTML：即Dynasmic html动态html，是html,css,js的集合不属于w3c规范 HTTP协议：超文本传输协议，用以规定客户端和服务器传输数据的格式，相似的有SMTP:邮件传输协议，FTP文件传输协议 2.计算机编码ASCII：用1字节（8位二进制数）表示一个字符，共有2^8=256个 ANSI：每个国家为了显示本国语言对ASCII码进行扩展，中国GBK2312，日本JIS，台湾BIG5 GBK：对GBK2312的扩展，能够显示少见的以及古汉字 Unicode：用4个字节表示一个字符，但是对ASCII码中存在的字符来说效率低下 GTF-8：(Unicode Transform Format)根据字符不同，采用不同字编码长度，字母1字节，汉字2字节，目前最通用的字符编码格式 3.HTML颜色值：颜色标识符：如blue,red,green rgb:格式rgb([red], [green], [blue])每一位可用0~255的十进制数表示，也有用rgba格式的，a（alpha）表示透明度，取值范围(0,1) 十六进制表示：#ff4400，每种色值用两位十六进制数表示，当色值两位数一样时可以简写为#f40 3.浏览器组成浏览器一般由以下几部分构成： 用户界面：除了主窗口以外的其他浏览器可见部分 内核：内核又由如下几个部分组成 浏览器引擎：查询操作渲染引擎 渲染引擎：构建页面的主要引擎，用于解析显示请求回来的文档资源（html和css） js解释器：解释执行js 网络：执行网络请求的模块 数据存储：浏览器用于在客户端硬盘存储诸如cookie等信息的模块4.主流浏览器内核12345IE(Internet Explorer): tridentGoogle Chrome: webkit/blinkSafari: webkit(webkit是谷歌和苹果联合开发)Firefox: GeckoOpera: presto","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]