---
title: 初识js
date: 2018-05-16 12:29:21
tags: ['基础', 'js']
---
# 初识js

这是关于javascript的第一篇文章，还是得好好说说，之后的javascript相关部分就不再废话了，毕竟我是个追求简约的人(￣▽￣)／
记不得第一见识javascript是什么时候了，或许是看头条上文章中那些五颜六色的代码块的时候吧，不过那时候并不知道javascript是什么东东，毕竟我以为所有我用的东西都是纯java,c,c++实现的，而这三种语言是没有如此漂亮的代码的。。。后来javascript词频越来越高，也开始慢慢的对javascript有所了解。
<!-- more -->
javascript是一门创造出来解决一些简单前端验证的脚本语言，但是刚开始我也把它和java联系起来，认为javascript和java关系很紧密，当看到它语法时才知道这就像鱼香肉丝和鱼，老婆饼和老婆的关系一样。看到一段小历史才明白这样取名的原因。
javascript一开始叫做livescript，是伴随着浏览器netscape navigator出现的一门脚本语言，改名叫做javascript纯粹是新语言为了推广而和当时如日中天的java挂钩。这个名字也就一直延续到了现在，更是迷惑了许多像我这样“鱼香肉丝党”。

# js特点

*   单线程：同一时间只能执行一件任务。
*   解释性语言：每读到一句js代码就翻译成二进制码执行，导致js运行速度比起编译性语言慢。
*   事件驱动：js目前主要用于网页中与用户的交互，用户操作鼠标键盘等设备触发页面绑定的事件执行对应的脚本。
*   弱类型：js中的变量没有java或是c中多样的变量类型，js中的声明的变量可以用于存储任意类型的值，甚至变量不声明也可以使用。
*   面向对象：js更关注使用对象能做什么，几乎所有操作都是基于对象的，在js中万物皆对象。
*   跨平台：依托于浏览器的js不用考虑java和c的平台支持，只要是支持js的浏览器，不用关心是什么平台都能运行。
*   js运行于浏览器处理了一些没必要靠后端处理的数据，减少了许多无意义的网络请求。
*   动态性：变量在运行时才知道具体是什么类型的值，并且定义的对象原型、方法等都可以重写改变。
    js通过`script`标签就可引入到页面中
    # 变量类型

*   原始值：存储在栈内存中的变量，值不可变。
    js支持五种原始值类型：Number、String、Boolean、undefined、null。undefined和null只有自身一个值。其中null也算是对象类型，是用于给空对象占位的。
*   引用值：引用值的存储栈堆配合。栈内存引用堆内存的地址，堆内存中存储引用值的值。
    三种引用值：Array、Object、Function
    js中的运算符和流控制语句和其他语言别无二致，但是在浏览器环境中，js包括ECMAScript、DOM、BOM。ECMAScript是javascript交由ECMA协会制定的规范浏览器js实现，DOM(Document Object Model)文档对象模型，提供了供脚本操作页面文档对象的接口；BOM(Browser Object Model)提供脚本操作浏览器的接口。以下说的js一般指的是ECMAScript3。
    ## 数组

    js中的数组有别于其他语言，弱数据类型的js允许数组中存储各种类型的数值，并且支持稀松数组，能够越界存取不会报错。

```
    //创建一个len长的空数组，以undefined填充
    new Array(len)
    // 创建一个元素为x1,x2,x3...的数组
    new Array(x1,x2,x3...)
    // 多维数组
    var arr = [[],[],[]] 

```

# 运算符

js中运算符和c及java没多大区别，都包含逻辑运算符，一元二元运算符等，只不过由于是脚本原因，一些运算符平时不太会用到，比如位运算符。位运算符会将数据转化为二进制数操作，因此速度上会提升不少，位运算符和逻辑运算符相似。

*   按位非(~)
    将原数转化成32位的二进制数后对这个二进制数每一位按位取非。
*   按位与(&)
    将两个操作数据转换成二进制数后，按两个二进制的每一位进行与操作，两位都是1返回1否则为0。
*   按位或(|)
    类似按位与，当两个比较位全为0返回0，否则返回1。
*   按位异或(^)
    两个比较位相同时为0，否则为1.
*   左移(<<)、有符号右移(>>)、无符号右移(>>>)
    将二进制数进行移位操作，左移不用考虑会以0填充空白位置，有符号右移以符号位填充空白，无符号右移以0填充空白位置。
    # 类型转换

    js中在操作数据时存在显示类型转换和隐式类型转换。
*   显示类型转换：通过调用调用一些原生对象将数据转换成所需要的类型，如Number(),String(),Boolean(),toString(),ParseInt(),ParseFloat()
*   隐式类型转换：isNaN(),一些一元操作符、布尔操作符、关系操作符、相等操作符等操作符时，会发生隐式的类型转换,保证操作符操作的两个数属于同种类型，在大部分数学操作符情况下是数字优先，加性操作符字符串优先，关系和布尔则是布尔值优先。
    当然有的时候在比较两个值时我们并不希望发生类型转换，这时需要用`===`操作符。undefined和null在比较中不会发生类型转换，虽然这两者的布尔类型值为0，但是两者与0的关系运算都为`false`，且规定undefined == null为true，_NaN == NaN为false_
    # 对象

    js中一切可操作的东西都是对象，对象有属性的增删改查功能，对象创建推荐使用对象字面量方法，此外还可以通过构造函数创建
    # 函数

    js中的函数实际也是对象，函数命名推荐小驼峰式写法，创建方法有构造函数、函数声明、函数表达式。有两种函数表达式：命名函数表达式、匿名函数表达式。
*   命名函数表达式

```
    var test = function test() {} //后面的test名字可以与前面不同，函数调用时只识别前一个test，后一个test作为字符串在test.name中保存。

```

*   匿名函数表达式

```
var test = function () {} //和命名函数表达式区别是test.name=test

```
函数的参数保存在`arguments`这个类数组中，且形参实参个数可以不对应，当形参实参有映射关系，一个改变，另一个也变。arguments实际是一个对象，含有以下属性：

```
arguments.callee //指向当前函数本身，常用于匿名函数调用自身
arguments.caller //返回当前函数的调用者，即this
arguments.length //返回当前参数长度

```

*   立即执行函数
    将函数变成表达式可以被`()`立即执行。一元运算符和逻辑操作符赋值给变量等可以使函数变成表达式
 
```
    (function (a) {
     console.log(a);
    }(1))

    var aa = function (a) {
     console.log(a);
    }(1)
    //访问aa未定义 

```

# 构造函数即自定义构造函数

*   Object(),String(),Array(),Date(),RegExp()等等是js中的内置对象，通过new操作符可以产生对应类型的对象。
*   自定义构造函数和普通函数没什么区别，只是为了和普通函数区分而认为规定了构造函数采用大驼峰式写法，首字母大写。
    构造函数简易原理：

1.  在函数体开始的地方创建this对象。
2.  将对应的方法属性保存到this对象上。
3.  隐式返回this
    当构造函数没有用new操作符时，相当于函数执行，此时this指向运行时的环境。

    > constructor返回对象的构造函数

# 包装类

包装类是为了避免在对Number,String,Boolean原始值按对象操作时不报错。

```
var num = 123;
//隐式new Number(123).say = '123';
num.say = '123';
//进行属性赋值操作后delete Number(123).abc
//访问num.say = undefined;

```

# 作用域

作用域规定了变量能够被访问调用的环境，在函数外声明的变量是全局变量作用域就是全局。在函数中声明的变量作用域是函数及函数嵌套的代码。js中只有函数作用域，没有块级作用域，在for循环中声明的变量全局window也能访问(假设是在全局的for语句)。
作用域链是函数保存在[[scope]]属性中的作用域中能够访问的对象的集合，每个函数在被创建时都会将全局对象(GO)放在作用域链的最底端，在函数运行时又会创建一个运行期上下文和一个活跃对象(AO)放在作用域链顶端，定义了函数运行时的环境this,形参等等。函数每一次调用都会产生一个全新的运行期上下文，在函数执行完毕之后函数自己的运行期上下文就被销毁并销毁对AO的引用，查找访问变量时，遵循从上往下原则，优先从活跃对象AO中查找，再顺着作用域链往下查找，若没找到则为未定义。

> bind，call，apply可以改变运行时的上下文；with,try-catch会改变作用域链。

# 闭包

当被当作返回值保存到外部的内部函数访问包含它的外部函数的作用域链时会产生闭包，闭包会导致本来应该随着外部函数执行完毕而销毁的AO不被释放而需要更多的内存，因为内部函数包含了外部函数的作用域。这里引用高性能javascript上的一个例子：

```
function assignEvents(){
 var id = "xdi9592";
 document.getElementById("save-btn").onclick = function(event){
 saveDocument(id);
 };
}

```

![闭包](clipboard.png)
本应该随着assignEvents执行完毕销毁的assignEvents的AO，因为事件监听中saveDocument还有对AO的引用，导致AO占用的内存没有被释放，产生了内存泄露的问题。
合理使用闭包可以创造出很多实用的功能，例如累加器：

```
function accumulator() {
 var count = 0;
 function add() {
 count ++;
 console.log(count);
 }
 return add;
}
var demo = accumulator();
demo();

```

# 原型、原型链

原型链是作用域链的延伸。原型是一个对象，包含了一些自身属性。在谷歌中如下：

```
function Test() {
 this.name = 'test';
}
var test = new Test();

```

![prototype](prototype.png)
其中**proto**是在火狐和chrome中实现的对象(这里是test)的原型属性，标准属性是[[Prototype]]，prototype是函数(这里是test的构造函数Test)的原型。就这样，实例对象的原型**proto**指向了构造函数的原型Test.prototype，构造函数原型对象Test.prototype的原型Test.prototype.**proto**指向Object.prototype(并且构造函数还具有constructor属性指向构造器Test函数)。这种指向关系构成了原型链。
有了原型链就可以通过在构造函数的原型上添加属性，构造函数的实例对象可以继承构造函数原型上的方法属性。这是js中实现继承的主要方法。
 
```
function Test() {
 this.name = 'test';
}
Test.prototype.sayName = function() {
 console.log(this.name);
}
var test = new Test();
test.sayName(); //打印出'test'

```

> 使用new创建的对象原型为Object.prototype，构造函数实例化对象的原型为构造函数的prototype,Object.create能够创建指定原型的对象。

# js运行机制

*   语法分析：先将所有代码检查一遍看有无语法错误。
*   全局预编译：

1.  生成GO对象
2.  变量声明作为GO属性，值为undefined。
3.  函数声明的函数名作为GO属性，值为函数体。

*   函数预编译：

1.  创建执行期上下文和AO对象。
2.  将形参和变量名作为AO的属性名，值为undefined
3.  传入的实参赋值给形参。
4.  将函数声明的函数名作为AO属性，值为函数体。

    > 未经声明的任何变量都看做是window对象的属性，同时声明的全局变量也是window的属性，区别是未经声明的变量可以delete删除，因为configurable=true，而声明的变量不能通过删除属性的delete删除

本篇完，算是对js的总体认识，之后再对原型继承和数组正则等进行扩充。
